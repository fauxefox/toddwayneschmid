<h1>The Church-Turing Thesis</h1>

<p>
    Last time, we saw Turing machines, our first honest-to-goodness full-scale mathematical model of computer hardware. 
    But why did we define it the way we did? 
    We had to make some choices about the design, right?
    And what's more, we seemed to go beyond what's normally represented by actual physical hardware: our definition allowed us to go beyond  \(0\)s and \(1\)s and write arbitrary symbols to our memory.
    That's not good, right? Why can't we just use \(0\) and \(1\)?
</p>

<p>
    Today, we are going to see that none of these choices matter in the end: no matter which "versions" of the Turing machine concept we 
</p>

<h2>Binary All the Way</h2>

<p>
    As our first example, let's argue that we can always 
</p>