<!-- THIS IS A COMPILED FILE 
 Compiled on 2025-11-11 -->



































































































<!DOCTYPE html>

<head>
	
	<meta charset="UTF-8">
	<meta name="author" content="Todd Schmid">
	
	<!-- Renders latex formulas -->
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
	<!-- Renders tikz figures mid page -->
    <link rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css">
    <script src="https://tikzjax.com/v1/tikzjax.js"></script>
	
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
	<link rel="stylesheet" href="../../../styles.css" />
	<link rel="stylesheet" href="../../course_styles.css" />
	<link rel="icon" href="../../../squidab.png" />
	
	<!-- * Customize for each course * -->
	<title>CSCI 341 Theory of Computation</title>
	<meta name="description" content="Course pages for CSCI 341.">
	<meta name="keywords" content="bucknell,theory,computer,science,schmid,csci341">
	<!-- ***************************** -->
</head>

<body>

<div id="content">

<!-- Header Section -->
<div id="course_head" style="text-align: left;">
	<h1 style="margin-bottom: 0; text-align: left;">CSCI 341 Theory of Computation</h1>
	<i>Fall 2025, with <a href="../../../teaching.html">Schmid</a></i>
	<div id="links">
		<!-- * Customize for each course * -->
		<a href="csci341_index.html"><span class="link">Syllabus</span></a>
		<a href="csci341_contents.html"><span class="link">Notes</span></a>
		<a href="csci341_resources.html"><span class="link">Resources</span></a>
		<a href= "csci341_assignments.html"><span class="link">Assignments</span></a>
		<!-- ***************************** -->
	</div>
</div>



<div id="stuff">


<!-- BEGINNING OF BODY -->
<div style="border: none; margin-bottom: -20px; padding: 0px; text-align: center;"><a href="../compiled/csci341_notes_3_07_reductions_of_halting.html"><span class="link" style="width:40%"> &larr; 3.7 Reductions Of Halting</span></a><a href="../compiled/csci341_notes_4_00_timing_turing_machines.html"><span class="link" style="width:40%">4.0 Timing Turing Machines &rarr;</span></a></div><h1>Recognizability and Enumerability</h1>

<p>
    Recall that a language \(L\) is <i>recognizable</i> if there is a Turing machine \(\mathcal T\) with a state \(x\) such that \(L = \{w \in A^* \mid \text{\(x\) halts on input \(w\)}\}\).
    While it is true that \(L_{Halt}\) is not decidable, there is a recognition procedure for \(L_{Halt}\).
    Indeed, a universal Turing machine \(\mathcal U\) can be used for this purpose.
</p>

<div class="exercise">
    <b>(Universally Recognized)</b>
    Let \(\mathcal U\) at state \(c\) be a universal Turing program. 
    Typically, \(\mathcal U\) at \(c\) typically just halts on input \(u \in A_{\mathcal U}^*\) (the universal Turing machine alphabet) if \(u\) is not of the form \(\lfloor \mathcal T\rfloor \mathtt{*} x \mathtt{*} w\) with \(\mathcal T\) a Turing machine, \(x\) a state of \(\mathcal T\), and a word \(w \in \{0,1\}^*\) (this amounts to a syntax error).
    We can change this behaviour rather easily: instead of halting, let \(\mathcal U\) at state \(c\) enter a forever-loop if it encounters a syntax error. 
    <ol>
        <li>
            Consider the string \(\lfloor \mathcal T\rfloor \mathtt{*} x \mathtt{*} w\) with \(\mathcal T\) a Turing machine, \(x\) a state of \(\mathcal T\), and a word \(w \in \{0,1\}^*\). 
            If \(\mathcal U_c(\lfloor \mathcal T\rfloor \mathtt{*} x \mathtt{*} w)\) is well-defined, i.e., \(c\) halts on input \(\lfloor \mathcal T\rfloor \mathtt{*} x \mathtt{*} w\), does \(x\) halt on input \(w\)? Or does it run forever? If it halts, write down its value.
        </li>
        <li>
            Given any string \(u \in A_{\mathcal U}^*\), if \(c\) halts on input \(u\), what can you tell me about the string \(u\)?
        </li>
        <li>
            Calculate the language recognized by \(\mathcal U_c\), i.e., \(\mathcal R(\mathcal U, c)\).
        </li>
    </ol>
</div>

<p>
    The issue here is that while \(L_{Halt}\) is recognizable, it is not additionally <i>co-recognizable</i>. 
    The terminology "co-recognizable" just means that the complement is also recognizable.
    Write \(\mathsf{coRec}\) for the family of co-recognizable languages.
</p>

<div class="exercise">
    <b>(Switching Sides)</b>
    Check that if \(L \in \mathsf{Rec}\), then \(A^* \setminus L \in \mathsf{coRec}\).
</div>

<div class="theorem">
    <b>(Recognizable + Corecognizable = Decidable)</b>
    Let \(L \subseteq A^*\) be a language. 
    If \(L\) is both recognizable and co-recognizable (meaning that \(A^*\setminus L\) is recognizable), then \(L\) is decidable.
    Formally, \(\mathsf{Dec} = \mathsf{Rec} \cap \mathsf{coRec}\).
</div>

<div class="problem">
    <b>(C + R = D)</b>
    Prove that if \(L \subseteq A^*\) is both recognizable and co-recognizable, then \(L\) is decidable.
    Explain why this implies that \(A^*\setminus L_{Halt}\) is not recognizable.
    <div class="hint">
        For the first part, you are essentially given two Turing machines here: one that recognizes \(L\) and one that recognizes \(A^*\setminus L\).
        Run them "in parallel".
        For the second, argue by contradition using the first part.
    </div>
</div>

<p>
    An immediate consequence of this fact is that we have also encountered our first unrecognizable language.
</p>

<div class="theorem">
    <b>(co-Halting Problem is Unecognizable)</b>
    The language \(A^* \setminus L_{Halt}\) is unrecognizable, i.e., \(A^* \setminus L_{Halt} \notin \mathsf{Rec}\).
</div>

<p>
    And as an immediate consequence of the co-halting problem being unrecognizable, we also have found our first <i>un-co-recognizable</i> language as well.
</p>

<div class="exercise">
    <b>(Not Not Not Not Halting Problem)</b>
    Is \(L_{Halt} \in \mathsf{coRec}\)?
</div>

<p>
    You might be wondering at this point if there are languages that are neither recognizable nor co-recognizable. 
    These languages are a bit exotic, but they do exist.
    If you're just looking for an example, there is a nice little lemma we can use to produce them.
</p>

<div class="lemma">
    <b>(Binary Branching Recognizable)</b>
    Let \(L \subseteq \{0,1\}^*\) be any language.
    If \(L \notin \mathsf{Rec}\), then 
    \[
        (\{0\} \cdot L) \cup (\{1\}\cdot (A^* \setminus L)) \notin \mathsf{Rec}
        \qquad \text{and} \qquad 
        (\{0\} \cdot L) \cup (\{1\}\cdot (A^* \setminus L)) \notin \mathsf{coRec}
    \]
</div>

<div class="proof">
    Let \(L \subseteq \{0,1\}^*\) be a language that is not recognizable, and let 
    \[
        U = (\{0\} \cdot L) \cup (\{1\}\cdot (A^* \setminus L))
    \]
    Assume for a contradiction that \(U \in \mathsf{Rec}\).
    Then there is a Turing machine \(\mathcal T\) with a state \(x\) such that 
    \(
        U = \mathcal R(\mathcal T, x)
    \).
    That is, for any \(w \in \{0,1\}^*\), \(w \in U\) if and only if \(x\) halts on input \(w\).
    We need to produce a Turing program that recognizes \(L\).
    Exhibit A: let \(\mathcal T'\) at its state \(y\) be the Turing program that writes a \(0\) to the left of the input tape and then proceeds with the Turing program \(\mathcal T\) at \(x\).
    Then 

    <div style="margin: 20px;">
    \(\mathcal T'\) at \(y\) halts on an input word \(w\)  <br>
    if and only if \(\mathcal T\) at \(x\) halts on input \(0w\) <br>
    if and only if \(0w \in U\) <br>
    if and only if \(w \in L\)
    </div>

    <p></p>
    Hence, \(\mathcal T'\) at \(y\) recognizes \(L\), which contradicts our initial assumption that \(L\) is unrecognizable.

    <p></p>
    Conversely, suppose that \(U\) is co-recognizable. 
    This is the same thing as saying that \(A^*\setminus U\) is recognizable.
    Suppose that \(\mathcal T\) at state \(x\) recognizes \(A^*\setminus U\).
    Since
    \[\begin{aligned}
        A^* \setminus U 
        &= A^* \setminus ((\{0\} \cdot L) \cup (\{1\}\cdot (A^* \setminus L))) \\
        &= (A^* \setminus (\{0\} \cdot L)) \cap (A^* \setminus (\{1\}\cdot (A^* \setminus L))) \\
        &= \{\varepsilon\} \cup (\{1\} \cdot L) \cup (\{0\}\cdot (A^* \setminus L))
    \end{aligned}\]
    we can argue similarly to how we did before that if \(A^* \setminus U \) is recognizable, then \(L\) is recognizable.
</div>

<!-- <div class="theorem">
    <b>(Diagonal Problem)</b>
    The <i>off-diagonal problem</i>, i.e., the language 
    \[
        L_{Diag} = \{\lfloor \mathcal T \rfloor \mathtt{*} x \mid \text{the state \(x\) of \(\mathcal T\) does not halt on input \(\lfloor \mathcal T \rfloor \mathtt{*} x\)}\}
    \]
    is both unrecognizable and un-co-recognizable: \(L_{All} \notin \mathsf{Rec}\) and \(L_{All} \notin \mathsf{coRec}\).
</div>

<div class="proof">
    For the first statement, we are going to reduce recognizing \(A^*\setminus L_{Halt}\) to recognizing \(L_{All}\).
    To that end, suppose that we had a Turing machine \(\mathcal T\) with a state \(x\) such that \(L_{All} = \mathcal R(\mathcal T, x)\).
    We build a recognizer for \(A^* \setminus L_{Halt}\) as follows:
</div> -->


<!--  -->
<h3>Enumerators and Recognizability</h3>

<p>
    Recognizability is closely related to <i>enumerator programs</i>.
    Roughly, an enumerator program is a program (state in a Turing machine) that computably represents a language as a <i>sequence of words</i> rather than just a set of words.
    For example, the language \(L_{\mathbb N} = \{1^n \mid n \in \mathbb{N}\}\) can be represented as the sequence 
    \[
        \varepsilon,~1,~11,~111,~1111,~\cdots
    \]
    This is really the most basic language-as-sequence, and so we're going to build our notion of "enumerability" on top of it.
</p>

<div class="definition">
    <b>(Enumerator)</b>
    Let \(L \subseteq A^*\) be a language and write \(L = \{w_n \mid n \in \mathbb N\}\).
    An <i>enumerator for \(L\)</i> is a Turing machine \(\mathcal E\) with a state \(x\) such that 
    \[
        \mathcal E_x(1^n) = w_n
    \]
    for all \(n \in \mathbb N\).
    
    <p></p>
    A language \(L\) is called <i>enumerable</i> if there is an enumerator for \(L\).
    The family of enumerable languages is written \(\mathsf{Enu}\).
</div>

<div class="remark">
    If the alphabet is finite or Since \(L\) is <i><a href="https://en.wikipedia.org/wiki/Countable_set" target="_blank">countable</a></i>, \(L\) is going to be countable as well, so we can always write the elements of \(L\) as a list, \(L = \{w_0, w_1, w_2, \dots\}\).
    This doesn't mean that \(L\) is enumerable!
</div>

<p>
    An easy (direct) consequence of the definition is that the Turing machine that does nothing and immediately halts is an enumerator for the language \(L_{\mathbb N}\) defined above.
</p>

<div class="exercise">
    Show that the language \(L_{\mathbb N} = \{1^n \mid n \in \mathbb{N}\}\) is enumerable.
</div>

<p>
    Let's take a look at a slightly more complex enumerable language.
</p>

<div class="example">
    Consider the language of all binary representations of natural numbers, 
    \[
        L_{bin} = \{\mathsf{bin}(n) \mid n \in \mathbb{N}\}
    \]
    This language can be written as a list, 
    \[
        0,~1,~10,~11,~100,~101,~110,~\dots
    \]
    where we simply add \(1\) to the number in binary at each step.
    <a href="../compiled/csci341_notes_3_04_reductions.html" target="_blank">In a previous section</a>, you showed how to build a Turing program called \(\mathtt{succ}\), which added one to its input represented as a binary number.
    For example, \(\mathcal T_{\mathtt{succ}}(1001) = 1010\), because \(9 + 1 = 10\).
    This is the key helper-subroutine that goes into out enumerator.
    Define the following Turing machine \(\mathcal E\) at its state \(\mathtt{enum}\) on input \(1^n\).
    Note that at the start, the tape is a sequence of \(1\)s.
    <ol>
        <li>
            Rewind the tape and write \(0\#\) to the beginning of the tape. 
            \[\begin{array}{l c c c c c c r}
                & \triangledown & & {\color{grey}(} & {\color{grey} 1^n} & {\color{grey})} & & \\
                \hline
                \cdots & 0 & \# & 1 & \cdots & 1 & & \cdots \\
                \hline
            \end{array}\]
        </li>
        <li>
            Fast forward to the end of the tape. 
            If the tape head reads \(\#\), erase and halt. 
            Otherwise, if it reads a \(1\), erase the \(1\) and proceed to step 3.
        </li>
        <li>
            Rewind to the cell immediately to the left of \(\#\). 
            Run \(\mathtt{succ}\) to add one to the number represented in binary before the \(\#\).
            Go to step 2.
        </li>
    </ol>
    For example, for \(n = 3\), 
    \[\begin{array}{l c c c c c c c c c r}
        & & & & & & \triangledown & & & & \text{input}\\
        \hline
        \cdots & & & & &  & 1 & 1 & 1 & & \cdots \\
        \hline
        %%%%%%%%%
        & & & & \triangledown & & & & & & \text{step 1}\\
        \hline
        \cdots & & & & 0 & \# & 1 & 1 & 1 & & \cdots \\
        \hline
        %%%%%%%%%
        & & & &  & & & & \triangledown & & \text{step 2} \\
        \hline
        \cdots & & & & 0 & \# & 1 & 1 &  & & \cdots \\
        \hline
        %%%%%%%%%
               & & & & \triangledown & & & &  & & \text{step 3} \\
        \hline
        \cdots & & & & 1 & \# & 1 & 1 &  & & \cdots \\
        \hline
        %%%%%%%%%
               & & & &   &    &   & \triangledown &  & & \text{step 2} \\
        \hline
        \cdots & & & & 1 & \# & 1 &  &  & & \cdots \\
        \hline
        %%%%%%%%%
               & & & \triangledown &   &    &   &  &  & & \text{step 3} \\
        \hline
        \cdots & & &1 & 0 & \# & 1 &  &  & & \cdots \\
        \hline
        %%%%%%%%%
               & & &  &   &     & \triangledown &  &  & & \text{step 2} \\
        \hline
        \cdots & & & 1 & 0 & \# &  &  &  & & \cdots \\
        \hline
        %%%%%%%%%
               & & & \triangledown &   &     &  &  &  & & \text{step 3} \\
        \hline
        \cdots & & & 1 & 1 & \# &  &  &  & & \cdots \\
        \hline
        %%%%%%%%%
               & & &  &   &  \triangledown   &  &  &  & & \text{step 2} \\
        \hline
        \cdots & & & 1 & 1 &  &  &  &  & & \cdots \\
        \hline
    \end{array}\]
    At the end, \(\mathcal E_{\mathtt{enum}}(111) = 11 = \mathsf{bin}(3)\).
</div>

<div class="exercise">
    <b>(Enumerating Doubles)</b>
    Show that the language 
    \[
        L_{2bin} = \{\mathsf{bin}(2n) \mid n \in \mathbb{N}\}
    \]
    is enumerable by designing an enumerator for it.
</div>

<p>
    As it turns out, recognizability and enumerability are equivalent.
</p>

<div class="theorem">
    <b>(Enumerable = Recognizable)</b>
    A language is recognizable if and only if it is enumerable. 
    That is, \(\mathsf{Rec} = \mathsf{Enu}\).
</div>

<div class="problem">
    Show that if a language is enumerable, then it is recognizable.

    <div class="hint">
        Let \(L \subseteq A^*\).
        Suppose that \(\mathcal E\) at state \(\mathtt{enum}\) is an enumerator for \(L\). 
        Construct a Turing machine \(\mathcal T\) with a state \(x\) that operates as follows: given a word \(w \in A^*\), \(x\) checks whether \(\mathcal E_y(1^n) = w\) for each \(n \in \mathbb N\), and halts when it succeeds.
    </div>
</div>

<div class="proof">(Sketch)
    The problem above shows that \(\mathsf{Enu} \subseteq \mathsf{Rec}\).
    For the other direction, let \(L \in \mathsf{Rec}\), and let \(\mathcal T\) at state \(x\) be a Turing program that recognizes \(L\).
    All that is left is to exhibit an enumerator for \(L\).
    The basic idea behind the construction is to start by enumerating all of the possible sequenece of \(0\)s and \(1\)s,
    \[
        \varepsilon,
        ~0,
        ~1,
        ~00,
        ~01,
        ~10,
        ~11,
        ~000,
        ~001,
        ~010,
        ~100,
        ~101, \dots
    \]
    For \(k \in \mathbb N\), write \(w_k\) for the \(k\)th string in this sequence.
    The pseudocode for the enumeration procedure is as follows: starting with an input string \(1^n\), we need to produce the \(n\)th word in the language.
    <div class="code">
        def enum : <br>
        &nbsp;&nbsp;set k = 1 <br>
        &nbsp;&nbsp;set m = n <br>
        &nbsp;&nbsp;while m > 0 : <br>
        &nbsp;&nbsp;&nbsp;&nbsp; for i from 1 to k : <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if \(x\) halts in \(\le k - i\) steps on input \(w_i\) : <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set m = m - 1 <br>
    </div>
    Intuitively, the \(n\)th time \(\mathtt{enum}\) sees that \(x\) halts, \(\mathtt{enum}\) halts.
</div>

<p>
    Altogether, we have the following picture.
    <img src="../imgs/Chomsky_complete.svg" />
</p>

<!-- 

<p>
    For us, it is usually going to be more convenient to use two tapes to establish enumerability.
    This is justified by the <a href="../compiled/csci341_notes_3_03_church_turing_thesis.html" target="_blank">Church-Turing thesis</a>.
</p>

<p>
    All of these can be built on the simplest enumerator program, which is \(\mathtt{enumerate\_all}\).
    Recall the Turing program \(x_{\mathtt{succ}}\) that satisfies
    \[
        \mathcal T_{x_{\mathtt{succ}}}(\mathsf{bin}(n)) = \mathsf{bin}(n + 1)
    \]
    Then \(\mathtt{enumerate\_all}\) is the program
    <div class="code">
        state enumerate_all <br>
        write 0.goto generate_next <br>
        <br>
        state generate_next <br>
        succ.goto generate_next
    </div>
    Starting from the empty string, this eventually writes every string of \(0\)s and \(1\)s to the tape!
</p>

<div class="definition">
    <b>(Enumerator)</b>
    Let \(L = \{w_1, w_2, w_3, \dots\}\) be the language consisting of words \(w_1, w_2, \dots\).
    An <i>enumerator for \(L\)</i> is a Turing program 
    \(\mathtt{enumerate\_L}\) that never halts, but outputs the following tape on input \(\varepsilon\):
    \[
        w_1\mathtt{\#}
    \]
</div>

<p>
    If we really wanted to make use of this program though, we need to insert a line of code that we can adlib later: let's say "other program".
    <div class="code">
        state enumerate_all <br>
        write 0.goto generate_next <br>
        <br>
        state generate_next <br>
        other_program.succ.goto generate_next
    </div>
    This is the key to the following problem.
</p>



<p>
    Again, we can 
</p> -->
<div style="border: none; margin-bottom: -20px; padding: 0px; text-align: center;"><a href="../compiled/csci341_notes_3_07_reductions_of_halting.html"><span class="link" style="width:40%"> &larr; 3.7 Reductions Of Halting</span></a><a href="../compiled/csci341_notes_4_00_timing_turing_machines.html"><span class="link" style="width:40%">4.0 Timing Turing Machines &rarr;</span></a></div>


<!-- END OF BODY -->
    <div style="height: 50px;border-top: 1px solid rgb(131, 131, 131);margin-top: 50px; padding: 20px; text-align: right;">
        <a href=""><span class="link">Top</span></a>
    </div>
</div>
</div>
</body>


</html>