<!-- THIS IS A COMPILED FILE 
 Compiled on 2025-11-11 -->



































































































<!DOCTYPE html>

<head>
	
	<meta charset="UTF-8">
	<meta name="author" content="Todd Schmid">
	
	<!-- Renders latex formulas -->
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
	<!-- Renders tikz figures mid page -->
    <link rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css">
    <script src="https://tikzjax.com/v1/tikzjax.js"></script>
	
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
	<link rel="stylesheet" href="../../../styles.css" />
	<link rel="stylesheet" href="../../course_styles.css" />
	<link rel="icon" href="../../../squidab.png" />
	
	<!-- * Customize for each course * -->
	<title>CSCI 341 Theory of Computation</title>
	<meta name="description" content="Course pages for CSCI 341.">
	<meta name="keywords" content="bucknell,theory,computer,science,schmid,csci341">
	<!-- ***************************** -->
</head>

<body>

<div id="content">

<!-- Header Section -->
<div id="course_head" style="text-align: left;">
	<h1 style="margin-bottom: 0; text-align: left;">CSCI 341 Theory of Computation</h1>
	<i>Fall 2025, with <a href="../../../teaching.html">Schmid</a></i>
	<div id="links">
		<!-- * Customize for each course * -->
		<a href="csci341_index.html"><span class="link">Syllabus</span></a>
		<a href="csci341_contents.html"><span class="link">Notes</span></a>
		<a href="csci341_resources.html"><span class="link">Resources</span></a>
		<a href= "csci341_assignments.html"><span class="link">Assignments</span></a>
		<!-- ***************************** -->
	</div>
</div>



<div id="stuff">


<!-- BEGINNING OF BODY -->
<div style="border: none; margin-bottom: -20px; padding: 0px; text-align: center;"><a href="../compiled/csci341_notes_3_07_reductions_of_halting.html"><span class="link" style="width:40%"> &larr; 3.7 Reductions Of Halting</span></a><a href="../compiled/csci341_notes_4_00_timing_turing_machines.html"><span class="link" style="width:40%">4.0 Timing Turing Machines &rarr;</span></a></div><h1>Recognizability and Enumerability</h1>

<p>
    Recall that a language \(L\) is <i>recognizable</i> if there is a Turing machine \(\mathcal T\) with a state \(x\) such that \(L = \{w \in A^* \mid \text{\(x\) halts on input \(w\)}\}\).
    While it is true that \(L_{Halt}\) is not decidable, there is a recognition procedure for \(L_{Halt}\).
    Indeed, a universal Turing machine \(\mathcal U\) can be used for this purpose.
</p>

<div class="exercise">
    <b>(Universally Recognized)</b>
    Let \(\mathcal U\) at state \(c\) be a universal Turing program. 
    Typically, \(\mathcal U\) at \(c\) typically just halts on input \(u \in A_{\mathcal U}^*\) (the universal Turing machine alphabet) if \(u\) is not of the form \(\lfloor \mathcal T\rfloor \mathtt{*} x \mathtt{*} w\) with \(\mathcal T\) a Turing machine, \(x\) a state of \(\mathcal T\), and a word \(w \in \{0,1\}^*\) (this amounts to a syntax error).
    We can change this behaviour rather easily: instead of halting, let \(\mathcal U\) at state \(c\) enter a forever-loop if it encounters a syntax error. 
    <ol>
        <li>
            Consider the string \(\lfloor \mathcal T\rfloor \mathtt{*} x \mathtt{*} w\) with \(\mathcal T\) a Turing machine, \(x\) a state of \(\mathcal T\), and a word \(w \in \{0,1\}^*\). 
            If \(\mathcal U_c(\lfloor \mathcal T\rfloor \mathtt{*} x \mathtt{*} w)\) is well-defined, i.e., \(c\) halts on input \(\lfloor \mathcal T\rfloor \mathtt{*} x \mathtt{*} w\), does \(x\) halt on input \(w\)? Or does it run forever? If it halts, write down its value.
        </li>
        <li>
            Given any string \(u \in A_{\mathcal U}^*\), if \(c\) halts on input \(u\), what can you tell me about the string \(u\)?
        </li>
        <li>
            Calculate the language recognized by \(\mathcal U_c\), i.e., \(\mathcal R(\mathcal U, c)\).
        </li>
    </ol>
</div>

<p>
    The issue here is that while \(L_{Halt}\) is recognizable, it is not additionally <i>co-recognizable</i>. 
    The terminology "co-recognizable" just means that the complement is also recognizable.
    Write \(\mathsf{coRec}\) for the family of co-recognizable languages.
</p>

<div class="exercise">
    <b>(Switching Sides)</b>
    Check that if \(L \in \mathsf{Rec}\), then \(A^* \setminus L \in \mathsf{coRec}\).
</div>

<div class="theorem">
    <b>(Recognizable + Corecognizable = Decidable)</b>
    Let \(L \subseteq A^*\) be a language. 
    If \(L\) is both recognizable and co-recognizable (meaning that \(A^*\setminus L\) is recognizable), then \(L\) is decidable.
    Formally, \(\mathsf{Dec} = \mathsf{Rec} \cap \mathsf{coRec}\).
</div>

<p>
    An immediate consequence of this fact is that we have also encountered our first unrecognizable language!
</p>

<div class="theorem">
    <b>(co-Halting Problem is Unecognizable)</b>
    The language \(A^* \setminus L_{Halt}\) is unrecognizable, i.e., \(A^* \setminus L_{Halt} \notin \mathsf{Rec}\).
</div>

<div class="problem">
    <b>(C + R = D)</b>
    Prove that if \(L \subseteq A^*\) is both recognizable and co-recognizable, then \(L\) is decidable.
    Explain why this implies that \(A^*\setminus L_{Halt}\) is not recognizable.
    <div class="hint">
        For the first part, you are essentially given two Turing machines here: one that recognizes \(L\) and one that recognizes \(A^*\setminus L\).
        Run them "in parallel".
        For the second, argue by contradition using the first part.
    </div>
</div>

<h3>Enumerators and Recognizability</h3>

<p>
    Recognizability is closely related to <i>enumerator programs</i>.
    Roughly, an enumerator program is a program (state in a Turing machine) that computably represents a language as a <i>sequence of words</i> rather than just a set of words.
    For example, the language \(L_{\mathbb N} = \{1^n \mid n \in \mathbb{N}\}\) can be represented as the sequence 
    \[
        \varepsilon,~1,~11,~111,~1111,~\cdots
    \]
    This is really the most basic language-as-sequence, and so we're going to build our notion of "enumerability" on top of it.
</p>

<div class="definition">
    <b>(Enumerator)</b>
    Let \(L \subseteq A^*\) be a language and write \(L = \{w_n \mid n \in \mathbb N\}\).
    An <i>enumerator for \(L\)</i> is a Turing machine \(\mathcal E\) with a state \(x\) such that 
    \[
        \mathcal E_x(1^n) = w_n
    \]
    for all \(n \in \mathbb N\).
    
    <p></p>
    A language \(L\) is called <i>enumerable</i> if there is an enumerator for \(L\).
    The family of enumerable languages is written \(\mathsf{Enu}\).
</div>

<div class="remark">
    If the alphabet is finite or Since \(L\) is <i><a href="https://en.wikipedia.org/wiki/Countable_set" target="_blank">countable</a></i>, \(L\) is going to be countable as well, so we can always write the elements of \(L\) as a list, \(L = \{w_0, w_1, w_2, \dots\}\).
    This doesn't mean that \(L\) is enumerable!
</div>

<p>
    An easy (direct) consequence of the definition is that the Turing machine that does nothing and immediately halts is an enumerator for the language \(L_{\mathbb N}\) defined above.
</p>

<div class="exercise">
    Show that the language \(L_{\mathbb N} = \{1^n \mid n \in \mathbb{N}\}\) is enumerable.
</div>

<p>
    Let's take a look at a slightly more complex enumerable language.
</p>

<div class="example">
    Consider the language of all binary representations of natural numbers, 
    \[
        L_{bin} = \{\mathsf{bin}(n) \mid n \in \mathbb{N}\}
    \]
    This language can be written as a list, 
    \[
        0,~1,~10,~11,~100,~101,~110,~\dots
    \]
    where we simply add \(1\) to the number in binary at each step.
    <a href="../compiled/csci341_notes_3_04_reductions.html" target="_blank">In a previous section</a>, you showed how to build a Turing program called \(\mathtt{succ}\), which added one to its input represented as a binary number.
    For example, \(\mathcal T_{\mathtt{succ}}(1001) = 1010\), because \(9 + 1 = 10\).
    This is the key helper-subroutine that goes into out enumerator.
    Define the following Turing machine \(\mathcal E\) at its state \(\mathtt{enum}\) on input \(1^n\).
    Note that at the start, the tape is a sequence of \(1\)s.
    <ol>
        <li>
            Rewind the tape and write \(0\#\) to the beginning of the tape. 
            \[\begin{array}{l c c c c c c r}
                & \triangledown & & {\color{grey}(} & {\color{grey} 1^n} & {\color{grey})} & & \\
                \hline
                \cdots & 0 & \# & 1 & \cdots & 1 & & \cdots \\
                \hline
            \end{array}\]
        </li>
        <li>
            Fast forward to the end of the tape. 
            If the tape head reads \(\#\), erase and halt. 
            Otherwise, if it reads a \(1\), erase the \(1\) and proceed to step 3.
        </li>
        <li>
            Rewind to the cell immediately to the left of \(\#\). 
            Run \(\mathtt{succ}\) to add one to the number represented in binary before the \(\#\).
            Go to step 2.
        </li>
    </ol>
    For example, for \(n = 3\), 
    \[\begin{array}{l c c c c c c c c c r}
        & & & & & & \triangledown & & & & \text{input}\\
        \hline
        \cdots & & & & &  & 1 & 1 & 1 & & \cdots \\
        \hline
        %%%%%%%%%
        & & & & \triangledown & & & & & & \text{step 1}\\
        \hline
        \cdots & & & & 0 & \# & 1 & 1 & 1 & & \cdots \\
        \hline
        %%%%%%%%%
        & & & &  & & & & \triangledown & & \text{step 2} \\
        \hline
        \cdots & & & & 0 & \# & 1 & 1 &  & & \cdots \\
        \hline
        %%%%%%%%%
               & & & & \triangledown & & & &  & & \text{step 3} \\
        \hline
        \cdots & & & & 1 & \# & 1 & 1 &  & & \cdots \\
        \hline
        %%%%%%%%%
               & & & &   &    &   & \triangledown &  & & \text{step 2} \\
        \hline
        \cdots & & & & 1 & \# & 1 &  &  & & \cdots \\
        \hline
        %%%%%%%%%
               & & & \triangledown &   &    &   &  &  & & \text{step 3} \\
        \hline
        \cdots & & &1 & 0 & \# & 1 &  &  & & \cdots \\
        \hline
        %%%%%%%%%
               & & &  &   &     & \triangledown &  &  & & \text{step 2} \\
        \hline
        \cdots & & & 1 & 0 & \# &  &  &  & & \cdots \\
        \hline
        %%%%%%%%%
               & & & \triangledown &   &     &  &  &  & & \text{step 3} \\
        \hline
        \cdots & & & 1 & 1 & \# &  &  &  & & \cdots \\
        \hline
        %%%%%%%%%
               & & &  &   &  \triangledown   &  &  &  & & \text{step 2} \\
        \hline
        \cdots & & & 1 & 1 &  &  &  &  & & \cdots \\
        \hline
    \end{array}\]
    At the end, \(\mathcal E_{\mathtt{enum}}(111) = 11 = \mathsf{bin}(3)\).
</div>

<div class="exercise">
    <b>(Enumerating Doubles)</b>
    Show that the language 
    \[
        L_{2bin} = \{\mathsf{bin}(2n) \mid n \in \mathbb{N}\}
    \]
    is enumerable by designing an enumerator for it.
</div>


<!-- 

<p>
    For us, it is usually going to be more convenient to use two tapes to establish enumerability.
    This is justified by the <a href="../compiled/csci341_notes_3_03_church_turing_thesis.html" target="_blank">Church-Turing thesis</a>.
</p>

<p>
    All of these can be built on the simplest enumerator program, which is \(\mathtt{enumerate\_all}\).
    Recall the Turing program \(x_{\mathtt{succ}}\) that satisfies
    \[
        \mathcal T_{x_{\mathtt{succ}}}(\mathsf{bin}(n)) = \mathsf{bin}(n + 1)
    \]
    Then \(\mathtt{enumerate\_all}\) is the program
    <div class="code">
        state enumerate_all <br>
        write 0.goto generate_next <br>
        <br>
        state generate_next <br>
        succ.goto generate_next
    </div>
    Starting from the empty string, this eventually writes every string of \(0\)s and \(1\)s to the tape!
</p>

<div class="definition">
    <b>(Enumerator)</b>
    Let \(L = \{w_1, w_2, w_3, \dots\}\) be the language consisting of words \(w_1, w_2, \dots\).
    An <i>enumerator for \(L\)</i> is a Turing program 
    \(\mathtt{enumerate\_L}\) that never halts, but outputs the following tape on input \(\varepsilon\):
    \[
        w_1\mathtt{\#}
    \]
</div>

<p>
    If we really wanted to make use of this program though, we need to insert a line of code that we can adlib later: let's say "other program".
    <div class="code">
        state enumerate_all <br>
        write 0.goto generate_next <br>
        <br>
        state generate_next <br>
        other_program.succ.goto generate_next
    </div>
    This is the key to the following problem.
</p>



<p>
    Again, we can 
</p> -->
<div style="border: none; margin-bottom: -20px; padding: 0px; text-align: center;"><a href="../compiled/csci341_notes_3_07_reductions_of_halting.html"><span class="link" style="width:40%"> &larr; 3.7 Reductions Of Halting</span></a><a href="../compiled/csci341_notes_4_00_timing_turing_machines.html"><span class="link" style="width:40%">4.0 Timing Turing Machines &rarr;</span></a></div>


<!-- END OF BODY -->
    <div style="height: 50px;border-top: 1px solid rgb(131, 131, 131);margin-top: 50px; padding: 20px; text-align: right;">
        <a href=""><span class="link">Top</span></a>
    </div>
</div>
</div>
</body>


</html>