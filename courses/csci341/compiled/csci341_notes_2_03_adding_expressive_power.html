<!-- THIS IS A COMPILED FILE 
 Compiled on 2025-10-07 -->



































































































<!DOCTYPE html>

<head>
	
	<meta charset="UTF-8">
	<meta name="author" content="Todd Schmid">
	
	<!-- Renders latex formulas -->
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
	<!-- Renders tikz figures mid page -->
    <link rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css">
    <script src="https://tikzjax.com/v1/tikzjax.js"></script>
	
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
	<link rel="stylesheet" href="../../../styles.css" />
	<link rel="stylesheet" href="../../course_styles.css" />
	<link rel="icon" href="../../../squidab.png" />
	
	<!-- * Customize for each course * -->
	<title>CSCI 341 Theory of Computation</title>
	<meta name="description" content="Course pages for CSCI 341.">
	<meta name="keywords" content="bucknell,theory,computer,science,schmid,csci341">
	<!-- ***************************** -->
</head>

<body>

<div id="content">

<!-- Header Section -->
<div id="course_head" style="text-align: left;">
	<h1 style="margin-bottom: 0; text-align: left;">CSCI 341 Theory of Computation</h1>
	<i>Fall 2025, with <a href="../../../teaching.html">Schmid</a></i>
	<div id="links">
		<!-- * Customize for each course * -->
		<a href="csci341_index.html"><span class="link">Syllabus</span></a>
		<a href="csci341_contents.html"><span class="link">Notes</span></a>
		<a href="csci341_resources.html"><span class="link">Resources</span></a>
		<a href= "csci341_assignments.html"><span class="link">Assignments</span></a>
		<!-- ***************************** -->
	</div>
</div>



<div id="stuff">


<!-- BEGINNING OF BODY -->
<div style="border: none; margin-bottom: -25px; padding: 0px; text-align: right;"><a href="../compiled/csci341_notes_2_02_parse_trees.html"><span class="link"> &larr; parse trees</span></a><a href="../compiled/csci341_notes_2_04_stack_automata.html"><span class="link">stack automata &rarr;</span></a></div><h1>Adding Expressive Power to Automata</h1>

<p>
    In the previous two lectures, we got acquainted with the <i>context-free languages</i> (\(\mathsf{CFL}\)).
    Context-free languages were defined to be the least solutions of polynomial systems, or equivalently, derived from/yielded by a variable in a (context-free) grammar.
    We saw from the Pumping Lemma episode that these extend strictly past the family of regular languages, and in fact many simple languages (eg., \(L_{a=b} = \{a^nb^n \mid n \in \mathbb{N}\}\)) can be seen in one family but not the other.
</p>

<img src="../imgs/Chomsky_Heirarchy_1.svg" />

<p>
    Grammars are very much like beefed-up regular expressions: they are a syntax with which we can specify languages.
    But here is one issue with grammars: <i>how do we decide if a particular word is derivable/parsable in a grammar?</i>
    It might be hard to see why this is a difficult question at first, but think about it: given a word \(w \in A^*\) and a grammar \(\mathcal G = (X, A, R)\) and a variable \(x \in X\), in order to reliably tell whether \(w\) is derivable from \(x\) in \(\mathcal G\) we would basically need to try every combination of rewrite rules starting from \(x\) until we stumble on \(w\).
    Not so efficient!
</p>

<p>
    What we really need is a <i>program that takes words as input and spits out yes-or-no answers</i>... 
    OK, well we've already been dealing with these: they're called automata. 
    But we know from the Pumping Lemma that finite automata are not good enough to handle all context-free languages. 
    So how do we proceed?
</p>

<p>
    Here's the general idea: finite automata are not enough.What we really need are infinite automata. 
    But <i>an infinite automaton doesn't necessarily require an infinite description</i>: we could, for instance, add a bit of memory to the mix. 
    This example from the Finite and Infinite Automata lecture comes to mind.
</p>

<div class="figure">
    <img src="../imgs/moneybags.png" alt="The angel and her money bag game again." />
    The Money Bags game from Finite and Infinite Automata.
</div>


<p>
    The state space for this game ended up being very much infinite: every time you made money, the money counter went up and suddenly you were in a completely new state. 
    But I was able to draw the whole game on screen! 
    The whole description of this infinite state space fits into a 350x300 grid of pixels.
    By adding a <i>counter</i>, we were able to take a finite description of a game and turn its state space into an infinite automaton.
    This is how we are going to develop algorithms for deciding whether a given word is derivable from a variable in a grammar: by adding memory to finite automata.
</p>

<p>
    Today is a fun day where we're going to get our hands on some automata that can do things that finite automata cannot. 
    In particular, we're going to get them to <i>count</i>. 
</p>

<h2>Counting</h2>

<p>
    The simplest kind of memory we can add onto an automaton is a <i>counter</i>, like in the Money Bags game above.
    The basic idea is behind a <i>counter automaton</i> is that it is like an ordinary automaton, but with every transition \(x \xrightarrow{a} y\) between states, you can add or subtract \(1\) or \(0\) to/from a <i>counter variable</i>, which can be thought of as an external device.
</p>

<div class="definition">
    <b>(Counter Automaton)</b>
    A <i>counter automaton</i> is a structure \(\mathcal A^\# = (Q, A, \delta, F)\) consisting of a set \(Q\) of states, an <i>input alphabet \(A\)</i>, a set \(F\) of <i>final</i> or <i>accepting states</i>, and a <i>transition relation</i>
    \[
        \delta \subseteq Q \times \big( A \times \{-1, +0, +1\} \big) \times Q
    \]
    If \((x, (a, p), y) \in \delta\), then we call this a <i>transition</i> and write 
    \[
        x \xrightarrow{a \mid p} y
    \]
    where here, \(p\) is one of \(+1\), \(+0\), or \(-1\).

    <p>
        Let \(x_0 \in Q\) be a state.
        A <i>run of \(\mathcal A^\#\) starting from \(x\)</i> is a path that keeps track of the <i>program state</i> and the <i>counter state</i>, \(x_i\) and \(n_i\) respectively.
        Formally, it is a sequence of transitions of the form
        \[
            (x_0, n_0) 
            \xrightarrow{a_1 \mid p_1} (x_1, n_1)
            \xrightarrow{a_2 \mid p_2} (x_2, n_2)
            \xrightarrow{a_3 \mid p_3} \cdots
            \xrightarrow{a_k \mid p_k} (x_k, n_k)
        \]
        in which the following conditions are met:
        <ol>
            <li>
                The path 
                \[
                    x_0 
                    \xrightarrow{a_1 \mid p_1} x_1
                    \xrightarrow{a_2 \mid p_2} x_2
                    \xrightarrow{a_3 \mid p_3} \cdots
                    \xrightarrow{a_k \mid p_k} x_k
                \]
                exists in \(\mathcal A^\#\).
            </li>
            <li>
                The counter state starts at \(0\), i.e., \(n_0 = 0\)
            </li>
            <li>
                The counter is never negative: For each \(i = 1, 2, \dots, k\), \(n_i \ge 0\).
            </li>
            <li>
                The value of the counter after a transition is determined by the transition action:
                For each \(i = 0, 2, \dots, k-1\),
                \[
                    n_{i+1} = \begin{cases}
                        n_i + 1 &\text{if \(p_i\) is \(+1\)} \\
                        n_i - 1 &\text{if \(p_i\) is \(-1\)} \\
                        n_i  &\text{if \(p_i\) is \(+0\)} \\
                    \end{cases}
                \]
            </li>
        </ol>
        Note that it is possible for \(k = 0\), so a path of length 0 always counts as a run.
    </p>
    <p>
        A word \(w = a_1 \cdots a_n \in A^*\) is <i>accepted by the state \(x_0\)</i> if there is a run in \(\mathcal A^\#\) starting from \(x_0\), 
        \[
            (x_0, n_0) 
            \xrightarrow{a_1 \mid p_1} (x_1, n_1)
            \xrightarrow{a_2 \mid p_2} (x_2, n_2)
            \xrightarrow{a_3 \mid p_3} \cdots
            \xrightarrow{a_k \mid p_k} (x_k, n_k)
        \]
        such that \(x_k \in F\) (the ending state \(x_k\) is accepting) and \(n_k = 0\) (the counter has been reset).
        This kind of run is called an <i>accepting run</i>.
    </p>
    <p>
        The <i>language accepted by \(x_0\)</i> is the language \(\mathcal L(\mathcal A^\#, x_0)\) of all words that are accepted by \(x_0\).
    </p>
</div>


<div class="example">
    <b>(First Counter)</b>
    The following state diagram depicts a counter automaton.
    <div class="figure">
        <img src="../imgs/first_counter.svg" />
        A counter automaton \(\mathcal A^\#\) with states \(x,y\), where \(F = \{y\}\), as well as the transition relation
        \[
            \delta = \{(x, a, +1, x), (x, a, +1, y), (y, b, -1, x), (y, b, -1, y)\}
        \]
    </div>
    Here is a run starting from \(x\):
    \[
        (x, 0) 
        \xrightarrow{a \mid +1} (y, 1) 
        \xrightarrow{b\mid -1} (y, 0)
    \]
    In this run, the <i>program state</i> transitions from \(x\) to \(y\) and then stays at \(y\), while the counter gets incremented and then decremented.
    Furthermore, this is an <i>accepting run</i> because \(y \in F\) and the counter state ends at \(0\).
    In other words, \(ab \in \mathcal L(\mathcal A^\#, x)\).

    <p>
        On the other hand, there is no run corresponding to the path \(x \xrightarrow{a \mid +1} y \xrightarrow{b \mid -1} y \xrightarrow{b\mid-1} x\).
        This has to do with the counter: remember that the counter state cannot fall below \(0\).
        So, if the counter state is \(0\), then trying to take a \(\xrightarrow{a_i \mid -1}\) step would invalidate the run (i.e., it would no longer count as a run).
        In the path \(x \xrightarrow{a \mid +1} y \xrightarrow{b \mid -1} y \xrightarrow{b\mid-1} x\), the corresponding attempt at a run gets stuck after the second transition.
    </p>
</div>

<div class="exercise">
    <b>(Learning to Count)</b>
    Consider the counter automaton in the First Counter example above. 
    <ol>
        <li>
            Show that the following words are accepted by \(x\) by exhibiting an accepting run.
            <ol type="i">
                <li>\(abab\)</li>
                <li>\(aabb\)</li>
                <li>\(ababaabb\)</li>
            </ol>
        </li>
        <li>
            Consider all possible paths in each case to show that the following words are <i>not</i> accepted by \(x\).
            <ol type="i">
                <li>\(aaabb\)</li>
                <li>\(abba\)</li>
                <li>\(aabbba\)</li>
            </ol>
        </li>
        <li>
            Use the Pumping Lemma to show that \(\mathcal L(\mathcal A^\#, x_0)\) is not regular.
        </li>
    </ol>
</div>

<p>
    (Finite) counter automata really are more powerful than finite automata, as you are about to see.
</p>

<div class="exercise">
    <b>(Counting for Yourself)</b>
    For each of the following languages \(L_i\), find a counter automaton \(\mathcal A^\#\) with a state \(x_0\) such that \(L_i = \mathcal L(\mathcal A^\#, x_i)\).
    <ol>
        <li>\(L_0 = \mathcal L((ab)^*)\)</li>
        <li>\(L_1 = \{a^nb^n \mid n \in \mathbb N\}\)</li>
        <li>\(L_2 = \{a^nb^kc^{n+k} \mid n,k \in \mathbb N\}\)</li>
    </ol>
</div>

<div class="challenge-exercise">
    <b>(Butterfly Effect)</b>
    Is the language 
    \[
        L = \{w \in \{a,b\}^* \mid \text{\(w\) has an equal number of \(a\)s and \(b\)s}\}
    \] 
    recognizable by a state in a counter automaton?
</div>

<div class="individual-exercise">
    <b>(Counting is Everything?)</b>
    Recall the notion of <i>balanced string of brackets</i> for multiple brackets, and consider the alphabet of brackets \(A = \{~\mathtt{(}, \mathtt{)}, \mathtt{[}, \mathtt{]}~\}\).
    Can a counter automaton recognize the language of all balanced strings of brackets \(w \in A^*\)?
    What about for just \(A = \{~\mathtt{(}, \mathtt{)}~\}\)?
</div>

<h2>Double-Counting</h2>

<p>
    Adding a counter to our automata is a simple way of increasing its expressive power.
    But you know what's cooler than a counter? 
    <i>Two counters</i><a href="https://www.youtube.com/shorts/WdNWfNxds_4" target="_blank">.</a>
</p>

<div class="exercise">
    <b>(Two Counters)</b>
    A <i>two-counter</i> automaton picks up the pace a little bit: instead of transitions of the form 
    \[
        x \xrightarrow{a \mid +1} y
    \] 
    a two-counter automaton has transitions like
    \[
        x \xrightarrow{a \mid +1; -1} y
    \]
    where the first \(+1\) increments one counter and \(-1\) decrements the other counter.
    Transitions with \(-1;+1\) or \(+0;+1\) or \(+1;+0\), and so on, are of course also possible.
    Remember that a counter automaton can only accept if its counter state is \(0\); the same should be true of two-counter automata (in that both counters should be \(0\)).
    <p>
        Where \(A = \{a,b,c, d\}\), design some two-counter automata to recognize the following languages.
    </p>
    <ol>
        <li>
            \(L_1 = \{a^nb^kc^nd^k \mid n,k \in \mathbb{N}\}\)
        </li>
        <li>\(L_2\), consisting of all the words \(w \in A^*\) such that \(w\) has the same numbers of \(a\)s, \(b\)s, and \(c\)s.</li>
        <li>\(L_3 = \{a^n b^n c^n \in A^* \mid n \in \mathbb N\}\)
        </li>
    </ol>
    <div class="hint">
        You cannot do either of these with one counter!
    </div>
</div>

<h2>A Short Experiment: Integer Counters</h2>

<p>
    Let's consider a slightly different kind of automaton: an <i>integer-counter automaton</i>.
    This is the same thing as a counter automaton, with one difference: in a run, the counter is allowed to fall below zero (i.e., be negative).
</p>

<div class="exercise">
    <b>(Does Negativity Help?)</b>
    Which of the following languages do you think you could recognize with an integer-counter automaton?
    <ol>
        <li>\(L_1 = \{a^nb^n \mid n \in \mathbb N\}\)</li>
        <li>\(L_2 = \{w \in \{a,b\}^* \mid \text{\(w\) has an equal number of \(a\)s and \(b\)s}\}\)</li>
        <li>\(L_3 = \{a^nb^kc^{n+k} \mid n,k \in \mathbb N\}\)</li>
        <li>
            \(L_4 = \{a^nb^kc^nd^k \mid n,k \in \mathbb{N}\}\)
        </li>
        <li>\(L_5\), consisting of all the words \(w \in A^*\) such that \(w\) has the same numbers of \(a\)s, \(b\)s, and \(c\)s.</li>
        <li>\(L_6 = \{a^n b^n c^n \in A^* \mid n \in \mathbb N\}\)
        </li>
    </ol>
</div>

<div class="problem">
    <b>(Cats > Dogs)</b>
    Let \(A = \{c, a, t, d, o, g\}\). 
    Design an integer counter automaton with a state \(x\) that accepts the language \(L_{cat}\) of all words \(w \in A^*\) such that the string "\(cat\)" appears in \(w\) more times than "\(dog\)" appears in \(w\)<a href="https://youtu.be/gknobwKAStE?si=p-JjpJrhaeSagtuz" target="_blank">.</a>
</div>

<h2>Other possibilities?</h2>

<p>
    Counters are the simplest type of memory to add to an automaton.
    But what about others?
</p>

<div class="individual-exercise">
    <b>(Dreaming Big)</b>
    In the next lecture, we are going to add a <i>stack</i> to our automata. 
    Before we do that, though, it is helpful to imagine what this might look like on your own first.
    What would an automaton with a stack look like?
    <ol>
        <li>
            What would a reasonable kind of transition between states in a <i>stack automaton</i> look like?
        </li>
        <li>
            What would a reasonable definition of "(accepting) run" be for stack automata?
        </li>
        <li>
            What kinds of languages do you think we could recognize with stack automata that we cannot recognize with counter automata?
        </li>
    </ol>
    If you had fun, try repeating this exercise but with a <i>queue</i> instead of a stack.
    <div class="hint">
        Adding a queue to our automata dramatically increases the power of the automaton, and <a href="http://pleasingfungus.com/#Manufactoria" target="_blank">makes it more fun</a> too. 
        Like, you could run Doom II on an automaton with a queue strapped to it.
    </div>
</div><div style="border: none; margin-bottom: -25px; padding: 0px; text-align: right;"><a href="../compiled/csci341_notes_2_02_parse_trees.html"><span class="link"> &larr; parse trees</span></a><a href="../compiled/csci341_notes_2_04_stack_automata.html"><span class="link">stack automata &rarr;</span></a></div>


<!-- END OF BODY -->
    <div style="height: 50px;border-top: 1px solid rgb(131, 131, 131);margin-top: 50px; padding: 20px; text-align: right;">
        <a href=""><span class="link">Top</span></a>
    </div>
</div>
</div>
</body>


</html>