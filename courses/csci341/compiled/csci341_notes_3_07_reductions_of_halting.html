<!-- THIS IS A COMPILED FILE 
 Compiled on 2025-11-04 -->



































































































<!DOCTYPE html>

<head>
	
	<meta charset="UTF-8">
	<meta name="author" content="Todd Schmid">
	
	<!-- Renders latex formulas -->
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
	<!-- Renders tikz figures mid page -->
    <link rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css">
    <script src="https://tikzjax.com/v1/tikzjax.js"></script>
	
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
	<link rel="stylesheet" href="../../../styles.css" />
	<link rel="stylesheet" href="../../course_styles.css" />
	<link rel="icon" href="../../../squidab.png" />
	
	<!-- * Customize for each course * -->
	<title>CSCI 341 Theory of Computation</title>
	<meta name="description" content="Course pages for CSCI 341.">
	<meta name="keywords" content="bucknell,theory,computer,science,schmid,csci341">
	<!-- ***************************** -->
</head>

<body>

<div id="content">

<!-- Header Section -->
<div id="course_head" style="text-align: left;">
	<h1 style="margin-bottom: 0; text-align: left;">CSCI 341 Theory of Computation</h1>
	<i>Fall 2025, with <a href="../../../teaching.html">Schmid</a></i>
	<div id="links">
		<!-- * Customize for each course * -->
		<a href="csci341_index.html"><span class="link">Syllabus</span></a>
		<a href="csci341_contents.html"><span class="link">Notes</span></a>
		<a href="csci341_resources.html"><span class="link">Resources</span></a>
		<a href= "csci341_assignments.html"><span class="link">Assignments</span></a>
		<!-- ***************************** -->
	</div>
</div>



<div id="stuff">


<!-- BEGINNING OF BODY -->
<div style="border: none; margin-bottom: -25px; padding: 0px; text-align: right;"><a href="../compiled/csci341_notes_3_06_the_halting_problem.html"><span class="link"> &larr; the halting problem</span></a><a href="../compiled/csci341_notes_3_08_recognizability_and_enumerability.html"><span class="link">recognizability and enumerability &rarr;</span></a></div><h1>Undecidability via the Halting Problem</h1>

<p>
    The undecidability of the Halting problem has many severe consequences.
    In a previous lecture, we already briefly talked about "reductions", where we were able to solve a problem \(P_1\) using a pre-existing solution to \(P_2\), i.e., we <i>reduced \(P_1\) to \(P_2\)</i>.
    Many other languages (decision problems) can be shown to be undecidable by reducing the halting problem to them.
</p>

<div class="definition">
    <b>(Decidability Reduction)</b>
    Let \(L_1,L_2 \subseteq A^*\) be languages. 
    We say that <i>\(L_1\) reduces to \(L_2\)</i> if the following statement holds: if \(L_2\in \mathsf{Dec}\), then \(L_1 \in \mathsf{Dec}\).
</div>

<p>
    Intuitively, \(L_1\) reduces to \(L_2\) if any decision procedure for \(L_2\) can be used to build a decision procedure for \(L_1\).
    Reducing the halting problem to a given decision problem is a standard technique for showing that a given language is not decidable.
</p>

<div class="lemma">
    <b>(Reduction to the Halting Problem)</b>
    Let \(L \subseteq A^*\).
    If \(L_{Halt}\) reduces to \(L\), then \(L \notin \mathsf{Dec}\).
</div>

<div class="proof">
    Suppose that \(L \in \mathsf{Dec}\) (i.e., that \(L\) is decidable). 
    Then, if \(L_{Halt}\) reduces to \(L\), we must also have \(L_{Halt} \in \mathsf{Dec}\).
    This last statement is false by the undecidability of the halting problem. 
    Therefore, \(L \notin\mathsf{Dec}\).
</div>

<p>
    This is a very handy lemma! 
</p>

<div class="example">
    <b>(Halting on Empty Problem)</b>
    Consider the language below, called the <i>halt-on-empty language</i>:
    \[
        L_{\varepsilon Halt} = \{\lfloor \mathcal T\rfloor \mathtt{*x} \mid \text{Turing machine \(\mathcal T\) at state \(x\) halts on input \(\varepsilon\)}\}
    \]
    We are going to argue that \(L_{Halt}\) reduces to \(L_{\varepsilon Halt}\). 
    Let's see how this works: suppose for a contradiction that \(\mathcal E\) is a Turing machine with a state \(x_\varepsilon\) that decides the language \(L_{\varepsilon Halt}\).
    We are going show how to use \(\mathcal E\) to design a Turing machine \(\mathcal H\) with a state \(x_{hlt}\) that decides \(L_{Halt}\).
    
    <p></p>
    Unlike the halt-on-empty problem, the input to the ordinary halting problem includes an input string in addition to the encoding of the Turing machine and state name.
    The general idea behind the construction is to take a string of the form \(\lfloor \mathcal T \rfloor \mathtt{*x*}w\) and add to \(\lfloor T \rfloor\) a string of code that represents some states that write \(w\) to its tape.
    Specifically, let \(\mathcal W\) with state \(y_{write}\) be a Turing program that satisfies 
    \[\begin{aligned}
        &\mathcal W_{y_{write}}(u \mathtt{*} x \mathtt{*} a_1a_2\cdots a_n) \\
        &= \mathtt{state\# x_{new} {/} write\# a_1.write\# a_2\dots write\# a_n.goto\# x{/}}u\mathtt{*x_{new}}
    \end{aligned}\]
    Then we can directly define \(\mathcal H\) and \(x_{hlt}\) by setting 
    \[
        \mathcal H_{x_{hlt}} ( w ) 
        = \mathcal E_{x_{\varepsilon}} (\mathcal W_{y_{write}} ( w ))
    \]
    By composing, we obtain the following:
    \[\begin{aligned}
        &\mathcal H_{x_{hlt}}(\lfloor \mathcal T \rfloor \mathtt{*x*}w) \\
        &= \mathcal E_{x_{\varepsilon}}\big( \mathcal W_{y_{write}}(\lfloor \mathcal T \rfloor \mathtt{*x*}w) \big) \\
        &= \mathcal E_{x_{\varepsilon}}\big( \mathtt{state\# x_{new} {/} write\# a_1.write\# a_2\dots write\# a_n.goto\# x{/}} \lfloor \mathcal T \rfloor \mathtt{*x_{new}} \big) \\
    \end{aligned}\]
    Since \(\mathcal E\) at \(x_{\varepsilon}\) decides \(L_{\varepsilon Halt}\), this shows us that \(\mathcal H_{x_{hlt}}(\lfloor \mathcal T \rfloor \mathtt{*x*}w) = 1\) if \(x\) in \(\mathcal T\) halts on input \(w\), and \(\mathcal H_{x_{hlt}}(\lfloor \mathcal T \rfloor \mathtt{*x*}w) = 0\) if \(x\) in \(\mathcal T\) does not halt on input \(w\).
    In other words, \(\mathcal H\) at \(x_{hlt}\) is a decider for the halting problem, which does not exist.
    It follows that \(L_{\varepsilon Halt}\) is undecidable.
</div>

<p>
    Many other problems that deal with "static analysis" (i.e., to encodings of Turing machines) can be reduced to the halting problem in the same way as the halting-on-empty problem.
</p>

<div class="exercise">
    <b>(Empty Language Problem)</b>
    The language below consists of all encodings of Turing machines (and states) that do not recognize any words.
    \[
        L_\emptyset = \big\{\lfloor \mathcal T\rfloor \mathtt{*x} \mid \mathcal R(\mathcal T, x) = \{\}\big\}
    \]
    Show that \(L_\emptyset\) is undecidable.
</div>

<h3>Rice's Theorem</h3>

<p>
    These "static-analysis" undecidability results are not coincidental, as the theorem we are about to state shows. 
    It's called Rice's Theorem, named after <a href="https://en.wikipedia.org/wiki/Henry_Gordon_Rice">Henry Gordon Rice</a>.
    The theorem requires some terminology to state precisely.
</p>

<div class="definition">
    <b>(Non-trivial and Extensional)</b>
    Let \(\mathbf{TM}\) be the set of all pairs \((\mathcal T, x)\) where \(\mathcal T\) is a Turing machine and \(x\) is a state of \(\mathcal T\).
    Let \(P \subseteq \mathbf{TM}\).
    <ul>
        <li>
            \(P\) is <i>nontrivial</i> if \(P \neq \{\}\) and \(P \neq \mathbf{TM}\).
        </li>
        <li>
            \(P\) is <i>extensional</i> if the following holds: 
            for any \((\mathcal T, x) \in P\) and any \((\mathcal S, y) \in \mathbf{TM}\), if \((\mathcal S, y)\) satisfies 
            \[\begin{aligned}
                \{w \mid \mathcal T_x(w) = 1\} &= \{w \mid \mathcal S_y(w) = 1\} \\
                \{w \mid \mathcal T_x(w) = 0\} &= \{w \mid \mathcal S_y(w) = 0\} 
            \end{aligned}\] 
            then \((\mathcal S, y) \in P\) also.
        </li>
    </ul>
</div>

<div class="theorem">
    <b>(Rice's)</b>
    Let \(P \subseteq \mathbf{TM}\) be nontrivial and extensional. 
    Then the language 
    \[
        L_P = \{\lfloor T \rfloor \mathtt{* x} \mid (\mathcal T, x) \in P\}
    \]
    is undecidable.
</div>

<div class="exercise">
    <b>(Nonempty Language Problem)</b>
    This language consists of all encodings of Turing machines (and states) that recognizes <i>at least one word</i>.
    \[
        L_\bullet = \big\{\lfloor \mathcal T\rfloor \mathtt{*x} \mid \mathcal R(\mathcal T, x) \neq \{\}\big\}
    \]
    Use Rice's Theorem to show that \(L_\bullet\) is undecidable.
</div>

<div class="exercise">
    <b>(Getting Even)</b>
    Let \[
        L_{\exists2} = \big\{\lfloor \mathcal T \rfloor \mathtt{*x} \mid \text{\(\mathcal T\) at \(x\) accepts an even-length word }\big\}
    \]
    Use Rice's theorem to show that \(L\) is undecidable.
</div>

<div class="problem">
    <b>(Equivalence Problem)</b>
    The language below consists of all pairs of encodings of Turing machines (and states) that recognize exactly the same words.
    \[
        L_= = \big\{\lfloor \mathcal T_1\rfloor \mathtt{*x_1\#}\lfloor \mathcal T_2\rfloor \mathtt{*x_2} \mid \mathcal R(\mathcal T_1, x_1) = \mathcal R(\mathcal T_2, x_2)\big\}
    \]
    Show that \(L_=\) is undecidable.
</div><div style="border: none; margin-bottom: -25px; padding: 0px; text-align: right;"><a href="../compiled/csci341_notes_3_06_the_halting_problem.html"><span class="link"> &larr; the halting problem</span></a><a href="../compiled/csci341_notes_3_08_recognizability_and_enumerability.html"><span class="link">recognizability and enumerability &rarr;</span></a></div>


<!-- END OF BODY -->
    <div style="height: 50px;border-top: 1px solid rgb(131, 131, 131);margin-top: 50px; padding: 20px; text-align: right;">
        <a href=""><span class="link">Top</span></a>
    </div>
</div>
</div>
</body>


</html>