<!-- THIS IS A COMPILED FILE 
 Compiled on 2025-11-10 -->



































































































<!DOCTYPE html>

<head>
	
	<meta charset="UTF-8">
	<meta name="author" content="Todd Schmid">
	
	<!-- Renders latex formulas -->
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
	<!-- Renders tikz figures mid page -->
    <link rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css">
    <script src="https://tikzjax.com/v1/tikzjax.js"></script>
	
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
	<link rel="stylesheet" href="../../../styles.css" />
	<link rel="stylesheet" href="../../course_styles.css" />
	<link rel="icon" href="../../../squidab.png" />
	
	<!-- * Customize for each course * -->
	<title>CSCI 341 Theory of Computation</title>
	<meta name="description" content="Course pages for CSCI 341.">
	<meta name="keywords" content="bucknell,theory,computer,science,schmid,csci341">
	<!-- ***************************** -->
</head>

<body>

<div id="content">

<!-- Header Section -->
<div id="course_head" style="text-align: left;">
	<h1 style="margin-bottom: 0; text-align: left;">CSCI 341 Theory of Computation</h1>
	<i>Fall 2025, with <a href="../../../teaching.html">Schmid</a></i>
	<div id="links">
		<!-- * Customize for each course * -->
		<a href="csci341_index.html"><span class="link">Syllabus</span></a>
		<a href="csci341_contents.html"><span class="link">Notes</span></a>
		<a href="csci341_resources.html"><span class="link">Resources</span></a>
		<a href= "csci341_assignments.html"><span class="link">Assignments</span></a>
		<!-- ***************************** -->
	</div>
</div>



<div id="stuff">


<!-- BEGINNING OF BODY -->
<div style="border: none; margin-bottom: -20px; padding: 0px; text-align: center;"><a href="../compiled/csci341_notes_3_06_the_halting_problem.html"><span class="link" style="width:40%"> &larr; 3.6 The Halting Problem</span></a><a href="../compiled/csci341_notes_3_08_recognizability_and_enumerability.html"><span class="link" style="width:40%">3.8 Recognizability And Enumerability &rarr;</span></a></div><h1>Undecidability via the Halting Problem</h1>

<p>
    The undecidability of the Halting problem has many severe consequences.
    In a previous lecture, we already briefly talked about "reductions", where we were able to solve a problem \(P_1\) using a pre-existing solution to \(P_2\), i.e., we <i>reduced \(P_1\) to \(P_2\)</i>.
    Many other languages (decision problems) can be shown to be undecidable by reducing the halting problem to them.
</p>

<div class="definition">
    <b>(Decidability Reduction)</b>
    Let \(L_1,L_2 \subseteq A^*\) be languages. 
    We say that <i>decidability of \(L_1\) reduces to decidability of \(L_2\)</i> (or simply that <i>\(L_1\) reduces to \(L_2\)</i>) if the following statement holds: if \(L_2\in \mathsf{Dec}\), then \(L_1 \in \mathsf{Dec}\).
</div>

<p>
    Intuitively, \(L_1\) reduces to \(L_2\) if any decision procedure for \(L_2\) can be used to build a decision procedure for \(L_1\).
    Reducing the halting problem to a given decision problem is a standard technique for showing that a given language is not decidable.
</p>

<div class="lemma">
    <b>(Reduction of the Halting Problem)</b>
    Let \(L \subseteq A^*\).
    If \(L_{Halt}\) reduces to \(L\), then \(L \notin \mathsf{Dec}\).
</div>

<div class="proof">
    Suppose that \(L \in \mathsf{Dec}\) (i.e., that \(L\) is decidable). 
    Then, if \(L_{Halt}\) reduces to \(L\), we must also have \(L_{Halt} \in \mathsf{Dec}\).
    This last statement is false by the undecidability of the halting problem. 
    Therefore, \(L \notin\mathsf{Dec}\).
</div>

<p>
    This is a very handy lemma! 
</p>

<div class="example">
    <b>(Halting on Empty Problem)</b>
    Consider the language below, called the <i>halt-on-empty language</i>:
    \[
        L_{\varepsilon} = \{\lfloor \mathcal T\rfloor \mathtt{*}x \mid \text{Turing machine \(\mathcal T\) at state \(x\) halts on input \(\varepsilon\)}\}
    \]
    We are going to argue that \(L_{Halt}\) reduces to \(L_{\varepsilon}\). 
    Let's see how this works: suppose for a contradiction that \(\mathcal E\) is a Turing machine with a state \(\mathtt{halts\_on\_\varepsilon}\) that decides the language \(L_{\varepsilon}\).
    We are going to show how to use \(\mathcal E\) to design a decision procedure for \(L_{Halt}\).
    
    <div class="exercise">
        <b>(Relating \(\varepsilon\) to Halting)</b>
        Show that \(\lfloor \mathcal T \rfloor \mathtt{*}x\mathtt{*}\varepsilon \in L_{Halt}\) if and only if \(\lfloor \mathcal T \rfloor \mathtt{*}x \in L_\varepsilon\).
    </div>

    <p></p>
    Unlike the halt-on-empty problem, the input to the ordinary halting problem includes an input string in addition to the encoding of the Turing machine and state name.
    The general idea behind the construction is to transform the string \(\lfloor \mathcal T \rfloor \mathtt{*}x\mathtt{*}w\) (that may or may not be an element of \(L_{Halt}\)) into the string \(\lfloor \mathcal T'\rfloor \mathtt{*} y\), where \(\mathcal T'\) is a Turing machine with a state \(y\) that writes the word \(w\) to the tape and then runs the program \(x\) in the original Turing machine \(\mathcal T\).
    This entails writing a program that prepends a string of code to \(\lfloor \mathcal T \rfloor\) that encodes the writing procedure for the word \(w\). 
    
    <div class="exercise">
        <b>(Write Your Own Prepend)</b>
        Design a Turing machine \(\mathcal W\) (for "writer") with a program \(\mathtt{prepend}\) that computes the following string transformer,
        \[\begin{aligned}
            &\mathcal W_{\mathtt{prepend}}(u \mathtt{*} x \mathtt{*} a_1\cdots a_n) \\
            &= \mathtt{state\#prepend {/} write\# a_1 \dots write\# a_n.goto\#} x \mathtt{/} u \mathtt{*prepend}
        \end{aligned}\]
        Compute the values of the following two expressions below:
        \[
            \mathcal U_c(
                \mathtt{state\#x{/}if\#0{:}write\#1.halt{*}x{*}0}
            ) = 
        \]
        \[
            \mathcal U_c(\mathcal W_{\mathtt{prepend}}(
                \mathtt{state\#x{/}if\#0{:}write\#1.halt{*}x{*}0}
            ) \mathtt{*} \varepsilon) = 
        \]
    </div>
    
    <p></p>
    Define the string 
    \[
        s = \mathtt{state\#prepend {/} write\# a_1 \dots write\# a_n.goto\#} x
    \]
    Now, when we run the new program, encoded as \(s\mathtt{/}\lfloor \mathcal T \rfloor\mathtt{*prepend}\), on the empty string, this gives the same result as running \(\mathcal T\) starting from \(x\) on the input string \(w\).
    Phrased in terms of a universal Turing machine,  
    \[
        \mathcal U_c(s\mathtt{/}\lfloor \mathcal T \rfloor\mathtt{*prepend}\mathtt{*}\varepsilon) = \mathcal T_x(w)
    \]
    What this allows us to do is use the decider for \(L_{\varepsilon}\), \(\mathcal E\) at state \(\mathtt{halts\_on\_\varepsilon}\), to check if the resulting program halts on an empty input. 
    As we have just seen, the new program (with \(s\) attatched) halts on \(\varepsilon\) if and only if \(x\) halts on input \(w\).
    This accomplishes our task.

    <p></p>
    Formally, we can directly define \(\mathcal H\) and \(\mathtt{dec\_if\_halt}\) by setting 
    \[
        \mathcal H_{\mathtt{dec\_if\_halt}} ( w ) 
        = \mathcal E_{\mathtt{halts\_on\_\varepsilon}} (\mathcal W_\mathtt{prepend} ( w ))
    \]
    By composing, we obtain the following:
    \[\begin{aligned}
        &\mathcal H_{\mathtt{dec\_if\_halt}}(\lfloor \mathcal T \rfloor \mathtt{*} x \mathtt{*} w) \\
        &= \mathcal E_{\mathtt{halts\_on\_\varepsilon}}\big( \mathcal W_\mathtt{prepend}(\lfloor \mathcal T \rfloor \mathtt{*} x \mathtt{*} w) \big) \\
        &= \mathcal E_{\mathtt{halts\_on\_\varepsilon}}\big( \mathtt{state\# \mathtt{prepend} {/} write\# a_1 \dots write\# a_n.goto\#} x\mathtt{/} \lfloor \mathcal T \rfloor \mathtt{*} \mathtt{prepend} \big) \\
    \end{aligned}\]
    Since \(\mathcal E\) at \(\mathtt{halts\_on\_\varepsilon}\) decides \(L_{\varepsilon}\), this shows us that \(\mathcal H_{\mathtt{dec\_if\_halt}}(\lfloor \mathcal T \rfloor \mathtt{*}x\mathtt{*}w) = 1\) if \(x\) in \(\mathcal T\) halts on input \(w\), and \(\mathcal H_{\mathtt{dec\_if\_halt}}(\lfloor \mathcal T \rfloor \mathtt{*} x \mathtt{*} w) = 0\) if \(x\) in \(\mathcal T\) does not halt on input \(w\).
    In other words, \(\mathcal H\) at \(\mathtt{dec\_if\_halt}\) is a decider for the halting problem.
    <img src="../imgs/halting_reduc_eg.svg" />
    By our Reduction of the Halting Problem lemma, it follows that \(L_{\varepsilon}\) is undecidable.
</div>

<p>
    The next two exercises are further steps toward understanding how the reduction in the example works.
</p>

<div class="exercise">
    <b>(The Writer, Concretely)</b>
    Consider the "writer" program \(\mathcal W_y\) in the example above. 
    Test it on the following examples:
    <ol>
        <li>
            \(\mathcal W_y(\mathtt{*x{*}0})=~\)
        </li>
        <li>
            \(\mathcal W_y(\mathtt{state\#z/if\#\_{:}move\#left.goto\#z{*}z{*}01})=~\)
        </li>
        <li>
            Consider the following code:
            <div class="code">
                state flip <br>
                if _ : goto halt <br>
                if 0 : write 1.move right.goto flip <br>
                if 1 : write 0.move right.goto flip
            </div>
            Let \(s\) be the string of symbols in the code above.
            Then \(\mathcal W_y(\mathtt{*flip*}11)=~\)
        </li>
    </ol>

    <!-- \[\begin{gathered}
        \mathcal W_y(\mathtt{*x{*}0}) 
        % = \mathtt{state\#x\_new/write\#0.goto\#x/{*}x\_new} \\\\
        \begin{aligned}
            &\mathcal W_y(\mathtt{state\#z/if\#\_{:}move\#left.goto\#z{*}z{*}01}) \\
            & = \mathtt{state\#x\_new/write\#0.write\#1.goto\#z/state\#z/if\#\_{:}move\#left.goto\#z{*}x\_new} 
        \end{aligned}
    \end{gathered}\] -->
</div>

<!-- <div class="exercise">
    <b>(The Writer, Concretely)</b>
    Consider the following program, 
    <div class="code">
        state flip <br>
        if _ : goto halt <br>
        if 0 : write 1.move right.goto flip <br>
        if 1 : write 0.move right.goto flip
    </div>
    Let \(s\)
    Calculate the string \(\)
</div> -->

<p>
    The halting problem can be reduced to many other problems that deal with "static analysis" (i.e., to encodings of Turing machines) in the same way as the halting-on-empty problem.
    Furthermore, once we know that the halting-on-empty problem is undecidable, we can discover the undecidability of other problems by reducing the halting-on-empty problem to them!
</p>

<div class="exercise">
    <b>(Empty Language Problem)</b>
    The language below consists of all encodings of Turing machines (and states) that do not recognize any words.
    \[
        L_\emptyset = \big\{\lfloor \mathcal T\rfloor \mathtt{*}x \mid \text{\(x\) does not halt on any input}\big\}
    \]
    Show that \(L_\emptyset\) is undecidable.
    <div class="hint">
        Reduce \(L_\varepsilon\) to \(L_{\emptyset}\) as follows:
        Let \(\mathcal E\) at \(y\) be a decision procedure for \(L_\emptyset\).
        Consider any Turing machine \(\mathcal C\) with state \(z\) that takes in a string \(u\mathtt{*}x\) and outputs \(s_x\mathtt{/}u\mathtt{*clear}\), where
        <div class="code" style="border: none;">
            <table>
                <tr>
                    <td>\(s_x =\)</td>
                    <td>
                        state%clear/<br>
                        if%_:goto%\(x\)/ <br>
                        if%0:erase.move%right.goto%clear/ <br>
                        if%1:erase.move%right.goto%clear
                    </td>
                </tr>
            </table>
        </div>
        (without all of the whitespace and line breaks).
        That is, 
        \[
            \mathcal C_z(u\mathtt{* x}) = s_x\mathtt{/}u\mathtt{*clear}
        \]
        Notice that \(s_x\mathtt{/}\lfloor \mathcal T\rfloor\mathtt{*x}\) is an encoding of the program that clears the tape and then runs \(\mathcal T\) from state \(x\).
        Show that 
        \[
            \mathcal E_y(\mathcal C_z(\lfloor \mathcal T\rfloor \mathtt{*x}))
            = \begin{cases}
                1 &\text{if }\varepsilon \in \mathcal R(\mathcal T, x) \\
                0 &\text{if }\varepsilon \notin \mathcal R(\mathcal T, x) 
            \end{cases}
        \]
        Conclude that \(L_{\emptyset} \notin \mathsf{Dec}\).
    </div>
</div>

<h3>Rice's Theorem</h3>

<p>
    These "static-analysis" undecidability results are not coincidental, as the theorem we are about to state shows. 
    It's called Rice's Theorem, named after <a href="https://en.wikipedia.org/wiki/Henry_Gordon_Rice">Henry Gordon Rice</a>.
    The theorem requires some terminology to state precisely.
</p>

<div class="definition">
    <b>(Non-trivial and Extensional)</b>
    Let \(\mathbf{TM}\) be the set of all pairs \((\mathcal T, x)\) where \(\mathcal T\) is a Turing machine and \(x\) is a state of \(\mathcal T\).
    Let \(P \subseteq \mathbf{TM}\).
    <ul>
        <li>
            \(P\) is <i>nontrivial</i> if \(P \neq \{\}\) and \(P \neq \mathbf{TM}\).
        </li>
        <li>
            \(P\) is <i>extensional</i> if the following holds: 
            for any \((\mathcal T, x) \in P\) and any \((\mathcal S, y) \in \mathbf{TM}\), if \(\mathcal T_x = \mathcal S_y\) (i.e., they are implementations of the same string transformer), then \((\mathcal S, y) \in P\) also.
        </li>
    </ul>
</div>

<div class="theorem">
    <b>(Rice's)</b>
    Let \(P \subseteq \mathbf{TM}\) be nontrivial and extensional. 
    Then the language 
    \[
        L_P = \{\lfloor \mathcal T \rfloor \mathtt{* x} \mid (\mathcal T, x) \in P\}
    \]
    is undecidable.
</div>

<p>
    Just a quick observation: 
</p>

<div class="individual-exercise">
    If \(P \subseteq \mathbf{TM}\) is nontrivial and extensional, then \(\mathbf{TM}\setminus P\) is nontrivial and extensional.
</div>

<div class="proof">
    Suppose for a contradiction that \(\mathcal P\) at state \(z\) is a decider for \(L_P\).
    Since \(P\) is nontrivial, there is a Turing program \((\mathcal M, m) \in P\) and a Turing program \((\mathcal N, n) \notin P\). 
    Without loss of generality, we can take \((\mathcal N, n) \notin P\) to be a (in fact, any, by extensionality) Turing program that never halts on any input (otherwise, we give the argument for \(\mathbf{TM}\setminus P\) instead). 
    Then we have 
    \[
        \mathcal P_z(\lfloor \mathcal M\rfloor \mathtt{* m}) = 1
        \qquad
        \mathcal P_z(\lfloor \mathcal N\rfloor \mathtt{* n}) = 0
    \]
    We are going to use \(\mathcal P\) and \(z\) to construct a decider, a Turing machine \(\mathcal H\) with a state \(\mathtt{dec\_if\_halt}\), for \(L_{Halt}\). 
    In other words, we will show that \(L_{Halt}\) reduces to \(L_P\), which establishes that \(L_P\) is undecidable.

    <p></p>
    For any fixed word \(w \in \{0,1\}^*\) and Turing machine \(\mathcal T\) with a state \(x\), construct a Turing machine \(\mathcal D[\mathcal T, x, w]\) with state \(d\) such that
    \[
        \mathcal D[\mathcal T,x,w]_d (u)
        = 
        \begin{cases}
            \mathcal P_z(u) &\text{if \(\mathcal T_x(w)\) is well-defined} \\
            \text{undefined} &\text{if \(\mathcal T_x(w)\) undefined}
        \end{cases}
    \]
    for any \(u \in A^*\).
    Note the following:
    <ol>
        <li>
            If \(\mathcal T_x(w)\) is well-defined (i.e., \(x\) halts on input \(w\)), then \(\mathcal D[\mathcal T, x, w] = \mathcal M_m\).
            Since \(\lfloor \mathcal M\rfloor \mathtt{*}m \in L_P\) and \(P\) is extensional, we would have
            \[
                \lfloor \mathcal D[\mathcal T, x, w]\rfloor \mathtt{*d} 
                \in L_P
            \]
        </li>
        <li>
            If \(\mathcal T_x(w)\) is undefined (i.e., \(x\) does not halt on input \(w\)), then \(\mathcal D[\mathcal T, x, w]_d = \mathcal N_n\), since \(\mathcal N\) at state \(n\) never halts on any input. 
            Since \(\lfloor \mathcal N\rfloor \mathtt{*}n \notin L_P\) and \(P\) is extensional, we would have
            \[
                \lfloor \mathcal D[\mathcal T, x, w]\rfloor \mathtt{*d} 
                \notin L_P
            \]
        </li>
    </ol>
    Therefore, if we can find a Turing machine \(\mathcal V\) with a state \(v\) such that 
    \[
        \mathcal V_v(\lfloor \mathcal T\rfloor \mathtt{*}x\mathtt{*}w)
        = \lfloor \mathcal D[\mathcal T, x, w]\rfloor \mathtt{*}d
    \]
    then we can define our decider for the halting problem by composition: 
    \[
        \mathcal H_{\mathtt{dec\_if\_halt}}
        = \mathcal P_z \circ \mathcal V_v
    \]
    We will return to the point that explains how to build \(\mathcal V_v\) in a moment. 
    First, let us see why \(\mathcal H\) at \(\mathtt{dec\_if\_halt}\) is a decider for \(L_{Halt}\).

    <p>
        Suppose \(x\) is a state of a Turing machine \(\mathcal T\) that halts on input \(w\).
        Then for any \(u \in \{0,1\}^*\), \(\mathcal D[\mathcal T, x, w]_d(u) = \mathcal M_m(u)\).
        By extensionality of \(P\), and because \(\mathcal P\) at \(z\) is a decider for \(L_P\), \(\mathcal P_z(\lfloor \mathcal D[\mathcal T, x, w]\rfloor \mathtt{*}d) = 1\). 
        By definition, we therefore have 
        \[\begin{aligned}
            \mathcal H_{\mathtt{dec\_if\_halt}}(\lfloor \mathcal T\rfloor \mathtt{*}x\mathtt{*}w) 
            &= \mathcal P_z \circ \mathcal V_v(\lfloor \mathcal T\rfloor \mathtt{*}x\mathtt{*}w) \\
            &= \mathcal P_z(\lfloor \mathcal D[\mathcal T, x, w]\rfloor \mathtt{*}d) \\
            &= \mathcal P_z(\lfloor \mathcal M\rfloor \mathtt{*}m) &\text{(extensionality)}\\
            &= 1
        \end{aligned}\]
        This shows that if \(x\) halts on input \(w\), then \(\mathcal H_{\mathtt{dec\_if\_halt}}(\lfloor \mathcal T\rfloor \mathtt{*}x\mathtt{*}w) = 1\).
    </p>

    <p>
        Conversely, suppose \(x\) is a state of a Turing machine \(\mathcal T\) that does not halt on input \(w\).
        Then for any \(u \in \{0,1\}^*\), \(\mathcal D[\mathcal T, x, w]_d(u) = \mathcal N_n(u)\).
        By extensionality of \(P\), \(\mathcal P_z(\lfloor \mathcal D[\mathcal T, x, w]\rfloor \mathtt{*}d) = 0\). 
        By definition, we therefore have 
        \[\begin{aligned}
            \mathcal H_{\mathtt{dec\_if\_halt}}(\lfloor \mathcal T\rfloor \mathtt{*}x\mathtt{*}w) 
            &= \mathcal P_z \circ \mathcal V_v(\lfloor \mathcal T\rfloor \mathtt{*}x\mathtt{*}w) \\
            &= \mathcal P_z(\lfloor \mathcal D[\mathcal T, x, w]\rfloor \mathtt{*}d) \\
            &= \mathcal P_z(\lfloor \mathcal N\rfloor \mathtt{*}n) &\text{(extensionality)}\\
            &= 0
        \end{aligned}\]
        This shows that if \(x\) does not halt on input \(w\), then \(\mathcal H_{\mathtt{dec\_if\_halt}}(\lfloor \mathcal T\rfloor \mathtt{*}x\mathtt{*}w) = 0\).
    </p>

    <p>
        The previous two paragraphs establish that \(\mathcal H\) at \(\mathtt{dec\_if\_halt}\) is a decider for \(L_{Halt}\). 
        We are now tasked with constructing \(\mathcal V\) with state \(v\).
        Let us sketch this quickly: we need \(v\) to (1) append the code of \(\mathcal P\) to \(\lfloor \mathcal T\rfloor\), as well as some programming to ensure that \(w\) gets written to a part of the tape, (2) augment the code of \(\mathcal T\) to only operate on the part of the tape that \(w\) gets written to, and (3) reroute all of the halting states of \(\mathcal T\) to a program that clears everything but \(u\) on the tape before running the program that corresponds to \(\mathcal P\).
</div>

<div class="challenge-exercise">
    <b>(\(\mathcal D\)etails)</b>
    Give a more detailed description of the Turing machine \(\mathcal V\) in the proof of Rice's theorem above.
</div>

<div class="exercise">
    <b>(Nonempty Language Problem)</b>
    This language consists of all encodings of Turing machines (and states) that recognizes <i>at least one word</i>.
    \[
        L_\bullet = \big\{\lfloor \mathcal T\rfloor \mathtt{*x} \mid \mathcal R(\mathcal T, x) \neq \{\}\big\}
    \]
    Use Rice's Theorem to show that \(L_\bullet\) is undecidable.
</div>

<div class="exercise">
    <b>(Getting Even)</b>
    Let \[
        L_{\exists2} = \big\{\lfloor \mathcal T \rfloor \mathtt{*x} \mid \text{\(\mathcal T\) at \(x\) accepts an even-length word }\big\}
    \]
    Use Rice's theorem to show that \(L\) is undecidable.
</div>

<div class="problem">
    <b>(Equivalence Problem)</b>
    The language below consists of all pairs of encodings of Turing machines (and states) that recognize exactly the same words.
    \[
        L_= = \big\{\lfloor \mathcal T_1\rfloor \mathtt{*x_1\#}\lfloor \mathcal T_2\rfloor \mathtt{*x_2} \mid \mathcal R(\mathcal T_1, x_1) = \mathcal R(\mathcal T_2, x_2)\big\}
    \]
    Show that \(L_=\) is undecidable.
</div><div style="border: none; margin-bottom: -20px; padding: 0px; text-align: center;"><a href="../compiled/csci341_notes_3_06_the_halting_problem.html"><span class="link" style="width:40%"> &larr; 3.6 The Halting Problem</span></a><a href="../compiled/csci341_notes_3_08_recognizability_and_enumerability.html"><span class="link" style="width:40%">3.8 Recognizability And Enumerability &rarr;</span></a></div>


<!-- END OF BODY -->
    <div style="height: 50px;border-top: 1px solid rgb(131, 131, 131);margin-top: 50px; padding: 20px; text-align: right;">
        <a href=""><span class="link">Top</span></a>
    </div>
</div>
</div>
</body>


</html>