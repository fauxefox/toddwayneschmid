<!-- THIS IS A COMPILED FILE 
 Compiled on 2025-11-05 -->



































































































<!DOCTYPE html>

<head>
	
	<meta charset="UTF-8">
	<meta name="author" content="Todd Schmid">
	
	<!-- Renders latex formulas -->
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
	<!-- Renders tikz figures mid page -->
    <link rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css">
    <script src="https://tikzjax.com/v1/tikzjax.js"></script>
	
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
	<link rel="stylesheet" href="../../../styles.css" />
	<link rel="stylesheet" href="../../course_styles.css" />
	<link rel="icon" href="../../../squidab.png" />
	
	<!-- * Customize for each course * -->
	<title>CSCI 341 Theory of Computation</title>
	<meta name="description" content="Course pages for CSCI 341.">
	<meta name="keywords" content="bucknell,theory,computer,science,schmid,csci341">
	<!-- ***************************** -->
</head>

<body>

<div id="content">

<!-- Header Section -->
<div id="course_head" style="text-align: left;">
	<h1 style="margin-bottom: 0; text-align: left;">CSCI 341 Theory of Computation</h1>
	<i>Fall 2025, with <a href="../../../teaching.html">Schmid</a></i>
	<div id="links">
		<!-- * Customize for each course * -->
		<a href="csci341_index.html"><span class="link">Syllabus</span></a>
		<a href="csci341_contents.html"><span class="link">Notes</span></a>
		<a href="csci341_resources.html"><span class="link">Resources</span></a>
		<a href= "csci341_assignments.html"><span class="link">Assignments</span></a>
		<!-- ***************************** -->
	</div>
</div>



<div id="stuff">


<!-- BEGINNING OF BODY -->
<div style="border: none; margin-bottom: -25px; padding: 0px; text-align: right;"><a href="../compiled/csci341_notes_3_06_the_halting_problem.html"><span class="link"> &larr; the halting problem</span></a><a href="../compiled/csci341_notes_3_08_recognizability_and_enumerability.html"><span class="link">recognizability and enumerability &rarr;</span></a></div><h1>Undecidability via the Halting Problem</h1>

<p>
    The undecidability of the Halting problem has many severe consequences.
    In a previous lecture, we already briefly talked about "reductions", where we were able to solve a problem \(P_1\) using a pre-existing solution to \(P_2\), i.e., we <i>reduced \(P_1\) to \(P_2\)</i>.
    Many other languages (decision problems) can be shown to be undecidable by reducing the halting problem to them.
</p>

<div class="definition">
    <b>(Decidability Reduction)</b>
    Let \(L_1,L_2 \subseteq A^*\) be languages. 
    We say that <i>\(L_1\) reduces to \(L_2\)</i> if the following statement holds: if \(L_2\in \mathsf{Dec}\), then \(L_1 \in \mathsf{Dec}\).
</div>

<p>
    Intuitively, \(L_1\) reduces to \(L_2\) if any decision procedure for \(L_2\) can be used to build a decision procedure for \(L_1\).
    Reducing the halting problem to a given decision problem is a standard technique for showing that a given language is not decidable.
</p>

<div class="lemma">
    <b>(Reduction of the Halting Problem)</b>
    Let \(L \subseteq A^*\).
    If \(L_{Halt}\) reduces to \(L\), then \(L \notin \mathsf{Dec}\).
</div>

<div class="proof">
    Suppose that \(L \in \mathsf{Dec}\) (i.e., that \(L\) is decidable). 
    Then, if \(L_{Halt}\) reduces to \(L\), we must also have \(L_{Halt} \in \mathsf{Dec}\).
    This last statement is false by the undecidability of the halting problem. 
    Therefore, \(L \notin\mathsf{Dec}\).
</div>

<p>
    This is a very handy lemma! 
</p>

<div class="example">
    <b>(Halting on Empty Problem)</b>
    Consider the language below, called the <i>halt-on-empty language</i>:
    \[
        L_{\varepsilon Halt} = \{\lfloor \mathcal T\rfloor \mathtt{*x} \mid \text{Turing machine \(\mathcal T\) at state \(x\) halts on input \(\varepsilon\)}\}
    \]
    We are going to argue that \(L_{Halt}\) reduces to \(L_{\varepsilon Halt}\). 
    Let's see how this works: suppose for a contradiction that \(\mathcal E\) is a Turing machine with a state \(x_\varepsilon\) that decides the language \(L_{\varepsilon Halt}\).
    We are going show how to use \(\mathcal E\) to design a Turing machine \(\mathcal H\) with a state \(x_{hlt}\) that decides \(L_{Halt}\).
    
    <p></p>
    Unlike the halt-on-empty problem, the input to the ordinary halting problem includes an input string in addition to the encoding of the Turing machine and state name.
    The general idea behind the construction is to take a string of the form \(\lfloor \mathcal T \rfloor \mathtt{*x*}w\) and add to \(\lfloor \mathcal T \rfloor\) a string of code that represents some states that write \(w\) to its tape.
    Specifically, let \(\mathcal W\) with state \(y_{write}\) be a Turing program that satisfies 
    \[\begin{aligned}
        &\mathcal W_{y_{write}}(u \mathtt{*} x \mathtt{*} a_1a_2\cdots a_n) \\
        &= \mathtt{state\# x_{new} {/} write\# a_1.write\# a_2\dots write\# a_n.goto\# x{/}}u\mathtt{*x_{new}}
    \end{aligned}\]
    Then we can directly define \(\mathcal H\) and \(x_{hlt}\) by setting 
    \[
        \mathcal H_{x_{hlt}} ( w ) 
        = \mathcal E_{x_{\varepsilon}} (\mathcal W_{y_{write}} ( w ))
    \]
    By composing, we obtain the following:
    \[\begin{aligned}
        &\mathcal H_{x_{hlt}}(\lfloor \mathcal T \rfloor \mathtt{*x*}w) \\
        &= \mathcal E_{x_{\varepsilon}}\big( \mathcal W_{y_{write}}(\lfloor \mathcal T \rfloor \mathtt{*x*}w) \big) \\
        &= \mathcal E_{x_{\varepsilon}}\big( \mathtt{state\# x_{new} {/} write\# a_1.write\# a_2\dots write\# a_n.goto\# x{/}} \lfloor \mathcal T \rfloor \mathtt{*x_{new}} \big) \\
    \end{aligned}\]
    Since \(\mathcal E\) at \(x_{\varepsilon}\) decides \(L_{\varepsilon Halt}\), this shows us that \(\mathcal H_{x_{hlt}}(\lfloor \mathcal T \rfloor \mathtt{*x*}w) = 1\) if \(x\) in \(\mathcal T\) halts on input \(w\), and \(\mathcal H_{x_{hlt}}(\lfloor \mathcal T \rfloor \mathtt{*x*}w) = 0\) if \(x\) in \(\mathcal T\) does not halt on input \(w\).
    In other words, \(\mathcal H\) at \(x_{hlt}\) is a decider for the halting problem.
    By our Reduction of the Halting Problem lemma, it follows that \(L_{\varepsilon Halt}\) is undecidable.
</div>

<p>
    The halting problem can be reduced to many other problems that deal with "static analysis" (i.e., to encodings of Turing machines) in the same way as the halting-on-empty problem.
    Furthermore, once we know that the halting-on-empty problem is undecidable, we can discover the undecidability of other problems by reducing the halting-on-empty problem to them!
</p>

<div class="exercise">
    <b>(Empty Language Problem)</b>
    The language below consists of all encodings of Turing machines (and states) that do not recognize any words.
    \[
        L_\emptyset = \big\{\lfloor \mathcal T\rfloor \mathtt{*x} \mid \mathcal R(\mathcal T, x) = \{\}\big\}
    \]
    Show that \(L_\emptyset\) is undecidable.
    <div class="hint">
        Reduce \(L_\emptyset\) to \(L_{\varepsilon Halt}\) as follows:
        Let \(\mathcal E\) at \(y\) be a decision procedure for \(L_\emptyset\).
        Consider any Turing machine \(\mathcal C\) with state \(z\) that takes in a string \(u\mathtt{* x}\) and outputs \(s\mathtt{/}u\mathtt{*x}\), where \(s\) is the string below:
        <div class="code" style="border: none;">
            state clear <br>
            if _ : goto x <br>
            if 0 : erase.move right.goto clear<br>
            if 1 : erase.move right.goto clear
        </div>
        That is, 
        \[
            \mathcal C_z(u\mathtt{* x}) = s\mathtt{/}u\mathtt{*x}
        \]
        Notice that \(s\mathtt{/}\lfloor \mathcal T\rfloor\mathtt{*x}\) is an encoding of the program that clears the tape and then runs \(\mathcal T\) from state \(x\).
        Show that 
        \[
            \mathcal E_y(\mathcal C_z(\lfloor \mathcal T\rfloor \mathtt{*x}))
            = \begin{cases}
                1 &\text{if }\varepsilon \in \mathcal R(\mathcal T, x) \\
                0 &\text{if }\varepsilon \notin \mathcal R(\mathcal T, x) 
            \end{cases}
        \]
        Conclude that \(L_{\emptyset} \notin \mathsf{Dec}\).
    </div>
</div>

<h3>Rice's Theorem</h3>

<p>
    These "static-analysis" undecidability results are not coincidental, as the theorem we are about to state shows. 
    It's called Rice's Theorem, named after <a href="https://en.wikipedia.org/wiki/Henry_Gordon_Rice">Henry Gordon Rice</a>.
    The theorem requires some terminology to state precisely.
</p>

<div class="definition">
    <b>(Non-trivial and Extensional)</b>
    Let \(\mathbf{TM}\) be the set of all pairs \((\mathcal T, x)\) where \(\mathcal T\) is a Turing machine and \(x\) is a state of \(\mathcal T\).
    Let \(P \subseteq \mathbf{TM}\).
    <ul>
        <li>
            \(P\) is <i>nontrivial</i> if \(P \neq \{\}\) and \(P \neq \mathbf{TM}\).
        </li>
        <li>
            \(P\) is <i>extensional</i> if the following holds: 
            for any \((\mathcal T, x) \in P\) and any \((\mathcal S, y) \in \mathbf{TM}\), if \(\mathcal T_x = \mathcal S_y\) (i.e., they are implementations of the same string transformer), then \((\mathcal S, y) \in P\) also.
        </li>
    </ul>
</div>

<div class="theorem">
    <b>(Rice's)</b>
    Let \(P \subseteq \mathbf{TM}\) be nontrivial and extensional. 
    Then the language 
    \[
        L_P = \{\lfloor T \rfloor \mathtt{* x} \mid (\mathcal T, x) \in P\}
    \]
    is undecidable.
</div>

<p>
    Just a quick observation: 
</p>

<div class="individual-exercise">
    If \(P \subseteq \mathbf{TM}\) is nontrivial and extensional, then \(\mathbf{TM}\setminus P\) is nontrivial and extensional.
</div>

<div class="proof">
    Suppose for a contradiction that \(\mathcal P\) at state \(z\) is a decider for \(L_P\).
    Since \(P\) is nontrivial, there is a Turing program \((\mathcal M, m) \in P\) and a Turing program \((\mathcal N, n) \notin P\). 
    Without loss of generality, we can take \((\mathcal N, n) \notin P\) to be a (in fact, any, by extensionality) Turing program that never halts on any input (otherwise, we give the argument for \(\mathbf{TM}\setminus P\) instead). 
    Then we have 
    \[
        \mathcal P_z(\lfloor \mathcal M\rfloor \mathtt{* m}) = 1
        \qquad
        \mathcal P_z(\lfloor \mathcal N\rfloor \mathtt{* n}) = 0
    \]
    We are going to use \(\mathcal P\) and \(z\) to construct a decider, a Turing machine \(\mathcal H\) with a state \(x_{hlt}\), for \(L_{Halt}\). 
    In other words, we will show that \(L_{Halt}\) reduces to \(L_P\), which establishes that \(L_P\) is undecidable.

    <p></p>
    For any fixed word \(w \in \{0,1\}^*\) and Turing machine \(\mathcal T\) with a state \(x\), construct a Turing machine \(\mathcal D[\mathcal T, x, w]\) with state \(d\) such that
    \[
        \mathcal D[\mathcal T,x,w]_d (u)
        = 
        \begin{cases}
            \mathcal P_z(u) &\text{if \(\mathcal T_x(w)\) is well-defined} \\
            \text{undefined} &\text{if \(\mathcal T_x(w)\) undefined}
        \end{cases}
    \]
    for any \(u \in A^*\).
    Note the following:
    <ol>
        <li>
            If \(\mathcal T_x(w)\) is well-defined (i.e., \(x\) halts on input \(w\)), then \(\mathcal D[\mathcal T, x, w] = \mathcal M_m\).
            Since \(\lfloor \mathcal M\rfloor \mathtt{*}m \in L_P\) and \(P\) is extensional, we would have
            \[
                \lfloor \mathcal D[\mathcal T, x, w]\rfloor \mathtt{*d} 
                \in L_P
            \]
        </li>
        <li>
            If \(\mathcal T_x(w)\) is undefined (i.e., \(x\) does not halt on input \(w\)), then \(\mathcal D[\mathcal T, x, w]_d = \mathcal N_n\), since \(\mathcal N\) at state \(n\) never halts on any input. 
            Since \(\lfloor \mathcal N\rfloor \mathtt{*}n \notin L_P\) and \(P\) is extensional, we would have
            \[
                \lfloor \mathcal D[\mathcal T, x, w]\rfloor \mathtt{*d} 
                \notin L_P
            \]
        </li>
    </ol>
    Therefore, if we can find a Turing machine \(\mathcal V\) with a state \(v\) such that 
    \[
        \mathcal V_v(\lfloor \mathcal T\rfloor \mathtt{*}x\mathtt{*}w)
        = \lfloor \mathcal D[\mathcal T, x, w]\rfloor \mathtt{*}d
    \]
    then we can define our decider for the halting problem by composition: 
    \[
        \mathcal H_{x_{hlt}}
        = \mathcal P_z \circ \mathcal V_v
    \]
    We will return to the point that explains how to build \(\mathcal V_v\) in a moment. 
    First, let us see why \(\mathcal H\) at \(x_{hlt}\) is a decider for \(L_{Halt}\).

    <p>
        Suppose \(x\) is a state of a Turing machine \(\mathcal T\) that halts on input \(w\).
        Then for any \(u \in \{0,1\}^*\), \(\mathcal D[\mathcal T, x, w]_d(u) = \mathcal M_m(u)\).
        By extensionality of \(P\), and because \(\mathcal P\) at \(z\) is a decider for \(L_P\), \(\mathcal P_z(\lfloor \mathcal D[\mathcal T, x, w]\rfloor \mathtt{*}d) = 1\). 
        By definition, we therefore have 
        \[\begin{aligned}
            \mathcal H_{x_{hlt}}(\lfloor \mathcal T\rfloor \mathtt{*}x\mathtt{*}w) 
            &= \mathcal P_z \circ \mathcal V_v(\lfloor \mathcal T\rfloor \mathtt{*}x\mathtt{*}w) \\
            &= \mathcal P_z(\lfloor \mathcal D[\mathcal T, x, w]\rfloor \mathtt{*}d) \\
            &= \mathcal P_z(\lfloor \mathcal M\rfloor \mathtt{*}m) &\text{(extensionality)}\\
            &= 1
        \end{aligned}\]
        This shows that if \(x\) halts on input \(w\), then \(\mathcal H_{x_{hlt}}(\lfloor \mathcal T\rfloor \mathtt{*}x\mathtt{*}w) = 1\).
    </p>

    <p>
        Conversely, suppose \(x\) is a state of a Turing machine \(\mathcal T\) that does not halt on input \(w\).
        Then for any \(u \in \{0,1\}^*\), \(\mathcal D[\mathcal T, x, w]_d(u) = \mathcal N_n(u)\).
        By extensionality of \(P\), \(\mathcal P_z(\lfloor \mathcal D[\mathcal T, x, w]\rfloor \mathtt{*}d) = 0\). 
        By definition, we therefore have 
        \[\begin{aligned}
            \mathcal H_{x_{hlt}}(\lfloor \mathcal T\rfloor \mathtt{*}x\mathtt{*}w) 
            &= \mathcal P_z \circ \mathcal V_v(\lfloor \mathcal T\rfloor \mathtt{*}x\mathtt{*}w) \\
            &= \mathcal P_z(\lfloor \mathcal D[\mathcal T, x, w]\rfloor \mathtt{*}d) \\
            &= \mathcal P_z(\lfloor \mathcal N\rfloor \mathtt{*}n) &\text{(extensionality)}\\
            &= 0
        \end{aligned}\]
        This shows that if \(x\) does not halt on input \(w\), then \(\mathcal H_{x_{hlt}}(\lfloor \mathcal T\rfloor \mathtt{*}x\mathtt{*}w) = 0\).
    </p>

    <p>
        The previous two paragraphs establish that \(\mathcal H\) at \(x_{hlt}\) is a decider for \(L_{Halt}\). 
        We are now tasked with constructing \(\mathcal V\) with state \(v\).
        Let us sketch this quickly: we need \(v\) to (1) append the code of \(\mathcal P\) to \(\lfloor \mathcal T\rfloor\), as well as some programming to ensure that \(w\) gets written to a part of the tape, (2) augment the code of \(\mathcal T\) to only operate on the part of the tape that \(w\) gets written to, and (3) reroute all of the halting states of \(\mathcal T\) to a program that clears everything but \(u\) on the tape before running the program that corresponds to \(\mathcal P\).
</div>

<div class="challenge-exercise">
    <b>(\(\mathcal D\)etails)</b>
    Give a more detailed description of the Turing machine \(\mathcal V\) in the proof of Rice's theorem above.
</div>

<div class="exercise">
    <b>(Nonempty Language Problem)</b>
    This language consists of all encodings of Turing machines (and states) that recognizes <i>at least one word</i>.
    \[
        L_\bullet = \big\{\lfloor \mathcal T\rfloor \mathtt{*x} \mid \mathcal R(\mathcal T, x) \neq \{\}\big\}
    \]
    Use Rice's Theorem to show that \(L_\bullet\) is undecidable.
</div>

<div class="exercise">
    <b>(Getting Even)</b>
    Let \[
        L_{\exists2} = \big\{\lfloor \mathcal T \rfloor \mathtt{*x} \mid \text{\(\mathcal T\) at \(x\) accepts an even-length word }\big\}
    \]
    Use Rice's theorem to show that \(L\) is undecidable.
</div>

<div class="problem">
    <b>(Equivalence Problem)</b>
    The language below consists of all pairs of encodings of Turing machines (and states) that recognize exactly the same words.
    \[
        L_= = \big\{\lfloor \mathcal T_1\rfloor \mathtt{*x_1\#}\lfloor \mathcal T_2\rfloor \mathtt{*x_2} \mid \mathcal R(\mathcal T_1, x_1) = \mathcal R(\mathcal T_2, x_2)\big\}
    \]
    Show that \(L_=\) is undecidable.
</div><div style="border: none; margin-bottom: -25px; padding: 0px; text-align: right;"><a href="../compiled/csci341_notes_3_06_the_halting_problem.html"><span class="link"> &larr; the halting problem</span></a><a href="../compiled/csci341_notes_3_08_recognizability_and_enumerability.html"><span class="link">recognizability and enumerability &rarr;</span></a></div>


<!-- END OF BODY -->
    <div style="height: 50px;border-top: 1px solid rgb(131, 131, 131);margin-top: 50px; padding: 20px; text-align: right;">
        <a href=""><span class="link">Top</span></a>
    </div>
</div>
</div>
</body>


</html>