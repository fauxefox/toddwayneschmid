<!-- THIS IS A COMPILED FILE 
 Compiled on 2025-11-27 -->



































































































<!DOCTYPE html>

<head>
	
	<meta charset="UTF-8">
	<meta name="author" content="Todd Schmid">
	
	<!-- Renders latex formulas -->
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
	<!-- Renders tikz figures mid page -->
    <link rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css">
    <script src="https://tikzjax.com/v1/tikzjax.js"></script>
	
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
	<link rel="stylesheet" href="../../../styles.css" />
	<link rel="stylesheet" href="../../course_styles.css" />
	<link rel="icon" href="../../../squidab.png" />
	
	<!-- * Customize for each course * -->
	<title>CSCI 341 Theory of Computation</title>
	<meta name="description" content="Course pages for CSCI 341.">
	<meta name="keywords" content="bucknell,theory,computer,science,schmid,csci341">
	<!-- ***************************** -->
</head>

<body>

<div id="content">

<!-- Header Section -->
<div id="course_head" style="text-align: left;">
	<h1 style="margin-bottom: 0; text-align: left;">CSCI 341 Theory of Computation</h1>
	<i>Fall 2025, with <a href="../../../teaching.html">Schmid</a></i>
	<div id="links">
		<!-- * Customize for each course * -->
		<a href="csci341_index.html"><span class="link">Syllabus</span></a>
		<a href="csci341_contents.html"><span class="link">Notes</span></a>
		<a href="csci341_resources.html"><span class="link">Resources</span></a>
		<a href= "csci341_assignments.html"><span class="link">Assignments</span></a>
		<!-- ***************************** -->
	</div>
</div>



<div id="stuff">


<!-- BEGINNING OF BODY -->
<div style="border: none; margin-bottom: -20px; padding: 0px; text-align: center;"><a href="../compiled/csci341_notes_3_05_universal_turing_machine.html"><span class="link" style="width:40%"> &larr; 3.5 Universal Turing Machine</span></a><a href="../compiled/csci341_notes_3_07_reductions_of_halting.html"><span class="link" style="width:40%">3.7 Reductions Of Halting &rarr;</span></a></div><h1>The Halting Problem</h1>

<p>
    Let's start with a practical scenario.
</p>
<p>
    You work for some big tech company, [redacted], that offers a service that allows users to upload and run their own software in the cloud.
    The way that this works is that after a user uploads some code to the server, they can edit it, compile, and allow their own clients to run it.
    When a client requests to run a user's program, that program gets put on a queue somewhere and waits for its turn to complete whatever task it has been assigned. 
</p>

<p>
    This is a wonderfully successful service, and something like 60% of the internet makes its way onto the servers! 
    This is great and all, but it turns out that the average user is not a great programmer: their programs are often buggy, and the worst are the ones that loop forever, i.e., they <i>never halt</i>.
    This is bad because it effectively means that nothing else on the queue after it gets to run!
    Your boss, [redacted], doesn't like this, and isn't pleased. 
    So he asks you, his best programmer, to fix it.
</p>

<p>
    One solution is of course to only let each program run for a certain amount of time. 
    There are several issues with this, but suffice it to say that certain very important bits of software need to be allowed more time than others to get their tasks completed, and it's hard to know in advance how much time exactly that is.
    So your boss, [redacted], wants you to be smarter about it (the irony is not lost on you), and write some program that takes a block of code as input and <b>decides</b> whether or not that block of code compiles to a program that halts.
</p>

<div class="definition">
    <b>(The Halting Problem)</b>
    <i>The Halting problem</i> \(L_{Halt}\) is the language of all string representations of Turing machine programs that halt on a given input. 
    Formally, 
    \[
        L_{Halt} = \left\{ \lfloor \mathcal T \rfloor \mathtt{*} x \mathtt{*} w ~\Big|~ \begin{gathered}
            \text{\(\mathcal T\) is a Turing machine with state \(x\), }\\
            \text{\(w \in A^*\), and \(x\) halts on input \(w\)}\\
        \end{gathered}\right\}
    \]
    is the set of all strings \(\lfloor \mathcal T\rfloor\mathtt{*x*}w\) such that \(w \in A^*\),  \(\mathtt{x}\) is the string representation a state of \(\mathcal T\), and \(x\) halts on input \(w\).
</div>

<div class="exercise">
    <b>(Understanding Halting)</b>
    Consider the encoding of a one-state Turing machine below, 
    \[
        \lfloor \mathcal T\rfloor = \mathtt{state\#s1{/}if\#0{:}move\#right{.}write\#0{.}goto\#s1}
    \]
    <ol>
        <li>Draw the Turing machine \(\mathcal T\).</li>
        <li>Is \(\lfloor\mathcal T\rfloor \mathtt{*s1{*}0} \in L_{Halt} \)?</li>
        <li>Is \(\lfloor\mathcal T\rfloor \mathtt{*s1{*}1} \in L_{Halt} \)?</li>
        <li>Is \(\lfloor\mathcal T\rfloor \mathtt{*s1{*}} \in L_{Halt} \)?</li>
        <li>Is \(\lfloor\mathcal T\rfloor \mathtt{*s2{*}0} \in L_{Halt} \)?</li>
    </ol>
</div>

<p>
    Effectively, what [redacted] is asking you to do is to design a decision procedure for \(L_{Halt}\).
    Unfortunately for your boss, this task is not possible.
</p>

<!-- -->
<h3>Undecidability of the Halting Problem</h3>

<p>
    Recall that we write \(\mathsf{Dec}\) for the family of all languages \(L \subseteq A^*\) such that there is a Turing machine \(\mathcal T\) with a state \(x\) such that \(x\) decides \(L\), i.e., 
    \[
        L = \{w \in A^* \mid \mathcal T_x(w) = 1\}
        \quad \text{and} \quad 
        A^*\setminus L = \{w \in A^* \mid \mathcal T_x(w) = 0\}
    \]

    Then \(L_{Halt} \notin \mathsf{Dec}\).
    In other words, the halting problem is <i>undecidable</i>.
</p>

<div class="theorem">
    <b>(Halting is Undecidable)</b>
    The Halting problem is undecidable, i.e., \(L_{Halt} \notin \mathsf{Dec}\).
</div>

<p>
    The proof is by contradiction: we are going to begin by assuming that \(L_{Halt}\) <i>is</i> decidable, and from that assumption conclude something absurd, like \(1 = 0\).
    <b>If there is any proof in this class that you should pay attention to, it is this one!</b>
</p>

<div class="proof">
    Assume for a contradiction that \(L_{Halt} \in \mathsf{Dec}\).
    Then there is a Turing machine \(\mathcal H\) with a state \(h\) such that \(\mathcal H_{h}(w) = 1\) if \(w \in L_{Halt}\) and \(\mathcal H_{h}(w) = 0\) if \(w \notin L_{Halt}\).
    We are going to use \(h\) as a subroutine in a different program that exhibits an impossible behaviour!
    
    <p></p>
    Let \(\mathtt{double\_input}\) be a Turing machine program that doubles the input string on the tape, i.e., turns the tape containing \(w\) into the tape containing \(ww\).
    This can be implemented in one of several ways.

    <div class="exercise">
        <b>(Implement a Doubler)</b>
        Design an explicit Turing machine \(\mathcal T\) with a state \(\mathtt{double\_input}\) such that \(\mathcal T_{\mathtt{double\_input}}(w) = ww\) for any word \(w \in \{0,1\}^*\).
    </div>

    Let us write \(\mathtt{det\_if\_halt}\) for the Turing program \(h\) in \(\mathcal H\), to make our construction below clearer.
    Now consider the following Turing machine, which we will call \(\mathcal D\).
    <div class="code">
        <table>
            <tr>
                <td>diag = </td>
                <td>
                    double_input.det_if_halt.goto liar
                </td>
            </tr>
            <tr>
                <td>liar = </td>
                <td>
                    if 0 : halt <br>
                    if 1 : goto loop
                </td>
            </tr>
            <tr>
                <td>loop = </td>
                <td>
                    move right.move left.goto loop
                </td>
            </tr>
        </table>
    </div>
    In the code for \(\mathcal D\) above, \(\mathtt{det\_if\_halt}\) decides whether the input string is of the form \(\lfloor \mathcal T\rfloor \mathtt{* x *} w\) for some Turing machine \(\mathcal T\) with state \(x\) that halts on input \(w\).

    <img src="../imgs/halting_undec_proof.svg" />
    <!-- It is important to note that the state \(\mathtt{diag}\) halts on a given input \(u\) <i>if and only if</i> \(u = \lfloor \mathcal T\rfloor \mathtt{*x*}w\) and \(\mathcal T\) at state \(x\) <i>does not</i> halt on input \(w\) (because \(h\) needs to output \(0\) to avoid the loop). -->
    
    <p></p>
    Now consider the input word 
    \[
        w = \lfloor \mathcal D\rfloor \mathtt{* {diag} *}
    \]
    Does \(\mathtt{diag}\) halt on input \(w\)?
    Let's check!
    We can split this into two cases.
        
    <p></p>
    <b>Case 1:</b>
    If \(\mathtt{diag}\) halts on input \(w\), then the output of running \(\mathtt{double\_input{.}det\_if\_halt}\) on the input word \(w\) must be \(0\), or else the \(\mathtt{liar}\) state enters the diverging \(\mathtt{loop}\).
    Therefore, we must have
    \[
        0 
        = \mathcal H_{h}(ww) 
        = \mathcal H_{h}(
            {\color{blue}\lfloor \mathcal D \rfloor} \mathtt{* {\color{red} {diag}} *} {\color{purple}\lfloor \mathcal D \rfloor \mathtt{* {diag} *}}
        ) 
    \]
    But this word is a representation of a Turing machine (blue), state (red), and input (purple)! 
    Namely,
    \[
        {\color{blue}\lfloor \mathcal D \rfloor} \mathtt{* {\color{red} {diag}} *} {\color{purple}\lfloor \mathcal D \rfloor \mathtt{* {diag} *}} 
        = {\color{blue}\lfloor \mathcal D \rfloor} \mathtt{* {\color{red} {diag}} *} {\color{purple} w }
    \]
    By definition of \(\mathtt{det\_if\_halt}\), \(\mathcal H_{h}({\color{blue}\lfloor \mathcal D \rfloor} \mathtt{* {\color{red} {diag}} *} {\color{purple} w }) = 0\) implies that \(\mathtt{diag}\) never halts on \({\color{purple} w } = {\color{purple}\lfloor \mathcal D \rfloor \mathtt{* {diag} *}}\).
    This contradicts the assumption at the beginning of this case.

    <div class="exercise">
        <b>(Needing Duplication)</b>
        Try this part of the proof again, but without running \(\mathtt{double\_input}\) before \(\mathtt{det\_if\_halt}\).
        What goes wrong?
    </div>

    <p></p>
    <b>Case 2:</b>
    If \(\mathtt{diag}\) does not halt on input \(\lfloor \mathcal D \rfloor \mathtt{* {diag} *}\), then the output of running \(\mathtt{double\_input{.}det\_if\_halt}\) on the input word \(w\) must be \(1\).
    This is because both \(\mathtt{double\_input}\) and \(\mathtt{det\_if\_halt}\) halt on all inputs, so the only path down which \(\mathtt{diag}\) loops forever is the one where the \(\mathtt{liar}\) state enters the diverging \(\mathtt{loop}\).
    In this case, we have
    \[
        1 
        = \mathcal H_{h}(ww) 
        = \mathcal H_{h}(
            {\color{blue}\lfloor \mathcal D \rfloor} \mathtt{* {\color{red} {diag}} *} {\color{purple}\lfloor \mathcal D \rfloor \mathtt{* {diag} *}}
        ) 
    \]
    Again, this word is a representation of a Turing machine (blue), state (red), and input (purple), 
    \[
        {\color{blue}\lfloor \mathcal D \rfloor} \mathtt{* {\color{red} {diag}} *} {\color{purple}\lfloor \mathcal D \rfloor \mathtt{* {diag} *}} = {\color{blue}\lfloor \mathcal D \rfloor} \mathtt{* {\color{red} {diag}} *} {\color{purple} w }
    \]
    By definition of \(\mathtt{det\_if\_halt}\), \(\mathcal H_{h}({\color{blue}\lfloor \mathcal D \rfloor} \mathtt{* {\color{red} {diag}} *} {\color{purple} w }) = 1\) implies that \(\mathtt{diag}\) halts on input \({\color{purple} w } = {\color{purple}\lfloor \mathcal D \rfloor \mathtt{* {diag} *}}\).
    This contradicts the assumption at the beginning of this case.

    <p></p>
    ...wait, but then we have shown that \(\mathtt{diag}\) both halts and also does not halt on input \(w\)?
    Since this is not possible, our initial assumption that \(\mathcal H\) and \(h\) (i.e., \(\mathtt{det\_if\_halt}\)) exist must have been false. 
    Therefore, \(L_{Halt}\) is not decidable.
    Formally, \(L_{Halt} \notin \mathsf{Dec}\).
</div>

<div class="exercise">
    <b>(Arguing)</b>
    With your team, comb through the proof above and make sure everybody understands each step. 
</div>

<div class="remark">
    The type of argument that is used to prove the undecidability of the halting problem is called a "diagonal argument", because it uses the "diagonal relation" (this refers to any relation of all the identical pairs \((x, x)\), because it looks like the graph of \(f(x) = x\)).
    The diagonal formally appears in the argument when we double the input string and use it as an input.
    <a href="https://en.wikipedia.org/wiki/Diagonal_argument" target="_blank">Diagonal arguments are extremely popular in logic (and other areas of mathematics and computer science)</a>. 
</div>
<div style="border: none; margin-bottom: -20px; padding: 0px; text-align: center;"><a href="../compiled/csci341_notes_3_05_universal_turing_machine.html"><span class="link" style="width:40%"> &larr; 3.5 Universal Turing Machine</span></a><a href="../compiled/csci341_notes_3_07_reductions_of_halting.html"><span class="link" style="width:40%">3.7 Reductions Of Halting &rarr;</span></a></div>


<!-- END OF BODY -->
    <div style="height: 50px;border-top: 1px solid rgb(131, 131, 131);margin-top: 50px; padding: 20px; text-align: right;">
        <a href=""><span class="link">Top</span></a>
    </div>
</div>
</div>
</body>


</html>