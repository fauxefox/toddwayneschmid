<!-- THIS IS A COMPILED FILE 
 Compiled on 2025-10-07 -->



































































































<!DOCTYPE html>

<head>
	
	<meta charset="UTF-8">
	<meta name="author" content="Todd Schmid">
	
	<!-- Renders latex formulas -->
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
	<!-- Renders tikz figures mid page -->
    <link rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css">
    <script src="https://tikzjax.com/v1/tikzjax.js"></script>
	
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
	<link rel="stylesheet" href="../../../styles.css" />
	<link rel="stylesheet" href="../../course_styles.css" />
	<link rel="icon" href="../../../squidab.png" />
	
	<!-- * Customize for each course * -->
	<title>CSCI 341 Theory of Computation</title>
	<meta name="description" content="Course pages for CSCI 341.">
	<meta name="keywords" content="bucknell,theory,computer,science,schmid,csci341">
	<!-- ***************************** -->
</head>

<body>

<div id="content">

<!-- Header Section -->
<div id="course_head" style="text-align: left;">
	<h1 style="margin-bottom: 0; text-align: left;">CSCI 341 Theory of Computation</h1>
	<i>Fall 2025, with <a href="../../../teaching.html">Schmid</a></i>
	<div id="links">
		<!-- * Customize for each course * -->
		<a href="csci341_index.html"><span class="link">Syllabus</span></a>
		<a href="csci341_contents.html"><span class="link">Notes</span></a>
		<a href="csci341_resources.html"><span class="link">Resources</span></a>
		<a href= "csci341_assignments.html"><span class="link">Assignments</span></a>
		<!-- ***************************** -->
	</div>
</div>



<div id="stuff">


<!-- BEGINNING OF BODY -->
<div style="border: none; margin-bottom: -25px; padding: 0px; text-align: right;"><a href="../compiled/csci341_notes_1_02_reading_words.html"><span class="link"> &larr; reading words</span></a><a href="../compiled/csci341_notes_1_04_finite_and_infinite_automata.html"><span class="link">finite and infinite automata &rarr;</span></a></div><h1>Languages and acceptance</h1>

<p>
    Today, we are going to return to the idea behind a <i>solution space</i>, which consisted of all of the sequences of legal moves that brought our puzzles into a "winning configuration".
    Just like how sequences of legal moves get abstracted to <i>words</i>, solution spaces are abstracted to <i>languages</i>.
</p>

<div class="definition">
    <b>(Language)</b>
    Let \(A\) be a set of input symbols. 
    A <i>language from \(A\)</i> is a set of words from \(A\).
    That is, a language is a subset \(L \subseteq A^*\).
</div>

<p>
    The "winning configurations" of automata are the <i>accepting states</i>: in the definition of an automaton \(\mathcal A = (Q, A, \delta, F)\), these are the states \(x \in F \subseteq Q\). 
    So the "solution space" of an automaton is, so to speak, the sequences of input letters that transition whichever state you start from to an accepting state.
</p>

<div class="definition">
    <b>(Language Acceptance)</b>
    Let \(\mathcal A = (Q, A, \delta, F)\) be an automaton, \(x \in Q\) be a state, and \(w \in A^*\) be a word from \(A\).
    Then \(w\) is <i>accepted</i> (or <i>recognized</i>) <i>by \(x\)</i> if there is an accepting state \(y \in F\) such that \(y \in \delta(x, w)\).
    The word \(w\) is <i>rejected by \(x\)</i> if it is not accepted by \(x\).

    The <i>language accepted</i> (or <i>decided</i>) <i>by \(x\)</i> is the set of words accepted by \(x\),
    \[
        \mathcal L(\mathcal A, x) = \big\{ w \in A^* \mid \text{\(x\) accepts \(w\)}  \big\}
    \]
    If \(\mathcal A\) is clear from context, we will just write \(\mathcal L(x)\) instead of \(\mathcal L(\mathcal A, x)\).
</div>

<p>
    A common turn of phrase you will see written is the statement "\(x\) accepts the language \(L\)". 
    What this means is that \(L = \mathcal L(\mathcal A, x)\).
</p>

<div class="remark">
    There are two common mistakes you are going to make at least a few times:
    the first one is to say that "an <i>automaton</i> accepts a language \(L \subseteq A^*\)". Automata do not accept languages, states do.
    Remember: states are programs, automata are the machines that can run them.
    <p>
        The second mistake is to say that a state \(x \in Q\) accepts a language \(L \subseteq A^*\) if every \(w \in L\) is accepted by \(x\). 
        This is equivalent to saying that \(\mathcal L(\mathcal A, x) \supseteq L\), not \(\mathcal L(\mathcal A, x) = L\)!
        The terminology "\(x\) <i>decides</i> \(L\)" is really a lot clearer, but the standard literature usually uses the word "accept".
        Not sure why. ðŸ™„
    </p>
</div>

<p>
    <b>Notation.</b> Given two sets \(X\) and \(Y\), we are going to write \(X \setminus Y\) for the set of elements of \(X\) that are not in \(Y\).
    Formally, 
    \(
        X \setminus Y = \{x \in X \mid x \notin Y\}
    \).    
    The set \(X \setminus Y\) is the <i>complement of \(Y\) in \(X\)</i>.
</p>

<div class="exercise" id="letemcook">
    <b>(Let 'em Cook)</b>
    For each of the following languages \(L_i \subseteq A^*\) below, design an automaton \(\mathcal A_i = (Q_i, A, \delta_i, F_i)\) with a state \(x \in Q_i\) such that \(x\) accepts \(L_i\), and briefly explain why your automaton accepts \(L_i\).
    Note that \(A = \{a, b\}\) in all of the cases below.
    <ol>
        <li>\(L_1 = \{a, aa, aaa\}\)</li>
        <li>\(L_2 = \{w \in A^* \mid \text{\(w\) ends with \(b\)}\}\)</li>
        <li>\(L_3 = \{w \in A^* \mid \text{\(w\) has an even number of \(a\)'s}\}\)</li>
        <li>\(L_4 = \{w \in A^* \mid \text{\(w\) has \(3k+1\) many \(a\)'s for some \(k \ge 0\)}\}\)</li>
        <li>\(L_5 = \{w \in A^* \mid \text{\(w\) either has \(3k+1\) or \(3k + 2\) many \(a\)'s for some \(k \ge 0\)}\}\)</li>
        <li>\(L_6 = A^* \setminus L_2\)</li>
        <li>\(L_7 = \{w \mid \text{every \(ab\) in \(w\) is immediately followed by a \(ba\)}\}\)</li>
    </ol>
</div>

<div class="exercise">
    <b>(Cooking Deterministically)</b>
    For each of the languages in Let 'em Cook, if you drew a nondeterministic or partial automaton, also draw a total deterministic one.
    <div class="hint">
        What should you do with the hidden "b"s?
    </div>
</div>

<!--Section-->
<h2>Common descriptions of languages</h2>
<p>
    In the Let 'em Cook problem, we saw some descriptions of languages of the form 
    \[
        L = \{w \in A^* \mid \textit{(something that has to be true about \(w\))}\}
    \]
    As you have probably gathered so far, the sentence to the right of the \(\mid\) tells you explicitly when a particular \(w \in A^*\) is in \(L\) or not.
    This method of defining sets is called <i>set comprehension</i>, because you are giving a comprehensive description of which elements are in the set.
    Set comprehension is the most common way of describing sets of things in general, and it will come up frequently in this course.
</p>

<div class="example">
    <b>(One mod Two)</b>
    Consider the automaton below with input letters \(A = \{a, b\}\). 
    <div class="figure">
        <img src="../imgs/x_0_odd.svg" />
    </div>
    Starting from either \(x_0\) or \(x_1\), reading a \(b\) does not change whether or not the word is accepted/rejected.
    But reading an \(a\) switches from accepting to rejecting:
    starting from \(x_0\), reading any \(a\) will activate the accepting state, and from \(x_1\) reading an \(a\) will deactivate the accepting state.
    So, starting from \(x_0\), every word of the form 
    \[
        b^{n_1}\ a\ b^{n_2}\ a\ b^{n_3}\ a\ b^{n_4}
    \]
    is accepted, where here, \(n_1, n_2, n_3, n_4 \in \mathbb N\).
    But we also, the words of the form 
    \[
        b^{n_1}\ a\ b^{n_2}\ a\ b^{n_3}\ a\ b^{n_4}\ a\ b^{n_5}\ a\ b^{n_6}
    \]
    are accepted. 
    It's not feasible to write down the language accepted by \(x_0\) this way, so we use a set comprehension to capture the idea for us. 
    \[
        \mathcal L(x_0) = \{w \in A^* \mid \text{\(w\) contains an odd number of \(a\)'s}\}
    \]
</div>

<div class="exercise">
    <b>(One More Than)</b>
    Using set comprehension, describe the languages accepted by the states \(x_0\) in the automata below. 
    <div class="figure">
        <img src="../imgs/moreautomata.svg" />
        <img src="../imgs/morethanfour.svg" />
    </div>
</div>

<p>
    Later, we will see a more compact notation for writing down languages.
</p>

<!-- PROBLEM -->
<div class="problem">
    <b>(Cooking with Gas)</b>
    In each of the following questions, you are asked to design an automaton with a state that accepts a given language.
    Draw its state diagram and its transition table, and briefly explain why the automaton works.
    <ol>
        <li>
            Over the alphabet \(A_1 = \{1, 2\}\) of input letters, define the function \(\mathrm{sum} \colon A^* \to \mathbb N\) by
            \[
                \mathrm{sum}(\varepsilon) = 0
                \qquad
                \mathrm{sum}(a_1a_2 \cdots a_n) = a_1 + a_2 + \cdots + a_n
            \]
            So, for example, \(\mathrm{sum}(1221) = 1 + 2 + 2 + 1 = 6\).
            Design an automaton with a state that accepts the language 
            \[
                L_1 = \{w \in A^* \mid \text{\(\mathrm{sum}(w)\) is a multiple of \(3\)} \}
            \]
        </li>
        <li>
            Over the alphabet \(A_2 = \{a, c, t\}\) of input letters, design an automaton with a state that accepts the language 
            \[
                L_2 = \{w \in A_2^* \mid \text{\(w\) contains the word \(cat\)}\}
            \]
        </li>
        <li>
            Over the alphabet \(A_3 = A_1 \cup A_2\) of input letters, design an automaton with a state that accepts the language 
            \[
                L_3 = L_1\cdot L_2 = \{wu \in A_3^* \mid \text{\(w \in L_1\) and \(u \in L_2\)}\}
            \]
        </li>
    </ol>
</div>

<!--Section-->
<h2>States as literal programs</h2>

<p>
    Returning to the idea that states of automata are programs, we can implement an automaton reading a string of input letters in any programming language rather easily.
    Working from the code back to an automaton isn't always as easy.
</p>

<div class="exercise">
    <b>(Pythonic Automaton I)</b>
    Go take a look at the Jupyter notebook linked here:
    <a href="https://colab.research.google.com/drive/1rHdYUT2oZc2GF6BTtsHksiUO_GJ64Vsx" target="_blank">(External link to code)</a>.
    This Python program under the Pythonic Automaton I header corresponds to a state in an automaton \(\mathcal A = (Q, A, \delta, F)\) where \(A = \{0,1\}\).
    <ol>
        <li>
            Run the program and test out which of the following strings are accepted/rejected (type "quit" to stop the program):
            <ul>
                <li>\(1\)</li>
                <li>\(010\)</li>
                <li>\(\varepsilon\) (just hit Enter/Return)</li>
                <li>\(011011\)</li>
            </ul>
        </li>
        <li>
            Write down a transition table for \(\mathcal A\) and draw a state diagram of \(\mathcal A\).
        </li>
        <li>
            Which state does the program correspond to?
        </li>
        <li>
            Using set comprehension, describe the language accepted by this state.
        </li>
    </ol>
    Make sure to thoroughly test out your state diagram of \(\mathcal A\) against the program.
</div>

<div class="exercise">
    <b>(Pythonic Automaton II)</b>
    Write a Python script in the same format as the Pythonic Automaton I (you can use Pythonic Automaton II as a template) that implements the state in the automaton \(\mathcal A_4\) you designed to accept \(L_4\) in <a href="#letemcook">Let 'em Cook</a>.
</div>

<!-- PROBLEM -->
<div class="problem">
    <b>(Pythonic Automaton III)</b>
    Write a Python script in the same format as the Pythonic Automaton I that implements state \(s_1\) in <a href="./csci341_1_0_games_and_state_diagrams.html#abstract-A" target="_blank">abstract state diagram (1)</a> from the games and puzzles section. 
    <b>Submit your program as a .py file named "pythonic_automaton_iii.py".</b>
    
    <i>In some sense, you just made a Sokoban game!</i>
</div><div style="border: none; margin-bottom: -25px; padding: 0px; text-align: right;"><a href="../compiled/csci341_notes_1_02_reading_words.html"><span class="link"> &larr; reading words</span></a><a href="../compiled/csci341_notes_1_04_finite_and_infinite_automata.html"><span class="link">finite and infinite automata &rarr;</span></a></div>


<!-- END OF BODY -->
    <div style="height: 50px;border-top: 1px solid rgb(131, 131, 131);margin-top: 50px; padding: 20px; text-align: right;">
        <a href=""><span class="link">Top</span></a>
    </div>
</div>
</div>
</body>


</html>