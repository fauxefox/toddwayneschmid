<!-- THIS IS A COMPILED FILE 
 Compiled on 2025-10-06 -->



































































































<!DOCTYPE html>

<head>
	
	<meta charset="UTF-8">
	<meta name="author" content="Todd Schmid">
	
	<!-- Renders latex formulas -->
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
	<!-- Renders tikz figures mid page -->
    <link rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css">
    <script src="https://tikzjax.com/v1/tikzjax.js"></script>
	
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
	<link rel="stylesheet" href="../../../styles.css" />
	<link rel="stylesheet" href="../../course_styles.css" />
	<link rel="icon" href="../../../squidab.png" />
	
	<!-- * Customize for each course * -->
	<title>CSCI 341 Theory of Computation</title>
	<meta name="description" content="Course pages for CSCI 341.">
	<meta name="keywords" content="bucknell,theory,computer,science,schmid,csci341">
	<!-- ***************************** -->
</head>

<body>

<div id="content">

<!-- Header Section -->
<div id="course_head" style="text-align: left;">
	<h1 style="margin-bottom: 0; text-align: left;">CSCI 341 Theory of Computation</h1>
	<i>Fall 2025, with <a href="../../../teaching.html">Schmid</a></i>
	<div id="links">
		<!-- * Customize for each course * -->
		<a href="csci341_index.html"><span class="link">Syllabus</span></a>
		<a href="csci341_contents.html"><span class="link">Notes</span></a>
		<a href="csci341_resources.html"><span class="link">Resources</span></a>
		<a href= "csci341_assignments.html"><span class="link">Assignments</span></a>
		<!-- ***************************** -->
	</div>
</div>



<div id="stuff">


<!-- BEGINNING OF BODY -->
<div style="border: none; margin-bottom: -25px; padding: 0px; text-align: right;"><a href="../compiled/csci341_notes_1_08_regular_expressions.html"><span class="link"> &larr; regular expressions</span></a><a href="../compiled/csci341_notes_1_10_algebra_of_regex.html"><span class="link">algebra of regex &rarr;</span></a></div><h1>Antimirov Derivatives</h1>

<p>
    We are currently working toward using regular expressions as a coding language for automata, specifically finite automata.
    Today, we are going to show that every regular expression represents a state in a finite automaton.  
    We are going to start by defining an infinite automaton, called the <i>Antimirov automaton</i> \(\mathcal A_{Ant}\), whose states are regular expressions and such that \(\mathcal L(\mathcal A_{Ant}, r) = \mathcal L(r)\) for every regular expression \(r \in \mathit{RExp}\).
    This is analogous to the Brzozowski automaton, whose states were languages.
    Except in this case, the states are expressions!
</p>

<h2>Antimirov Derivatives</h2>

<p>
    When we built the Brzozowski automaton, we needed to define what was called the <i>Brzozowski derivative</i> of a language, \(a^{-1}L\) for each \(a \in A\) and \(L \in 2^{A^*}\).
    To define the Antimirov automaton, we have to do something similar---we are going to define a notion of derivative for regular expressions.
    However, there is an important difference between the Brzozowski automaton and the Antimirov automaton: the Brzozowski automaton is total and deterministic, but the Antimirov automaton is neither. 
    In other words, a regular expression can have <i>multiple</i> Antimirov derivatives.
</p>

<p>
    Here is the formal definition:
</p>

<div class="definition">
    <b>(Antimirov Automaton)</b>
    Let \(A\) be an alphabet of input symbols.
    The <i>Antimirov automaton</i> is the automaton \(\mathcal A_{Ant} = (\mathit{RExp}, A, \delta, F)\), where \(\delta\) and \(F\) are defined recursively by the following rules:

    <p>
        Starting with \(F\), we define 
        <ol type="i">
            <li>\(\emptyset \notin F\) and \(a \notin F\) for any \(a \in A\)</li>
            <li>\(\varepsilon \in F\)</li>
            <li>for any regular expression \(r\), we have \(r^* \in F\)</li>
        </ol>
        and recursively, for regular expressions \(r_1,r_2 \in \mathit{RExp}\):
        <ol start=4 type="i">
            <li>\((r_1 + r_2) \in F\) if and only if \(r_1 \in F\) or \(r_2 \in F\)</li>
            <li>\((r_1 \cdot r_2) \in F\) if and only if \(r_1 \in F\) and \(r_2 \in F\)</li>
        </ol>
    </p>

    <p>
        Now let's define \(\delta\).
        We are going to use the reading notation from before to define \(\delta\), where we wrote \(\delta(x, w)\) to denote the set of states that are active after reading a word \(w\) from \(x\).
        In the Antimirov automaton, states are regular expressions, so in each of the equations below describing \(\delta\), you will see \(\delta(r, a)\).
        Here, \(r\) is a regular expression and \(a\) is a letter.
    </p>

    <p>
        Let's get into it:
        for any \(a \in A\), we define
        <ol type="A">
            <li>\(\delta(\emptyset, a) = \{\}\)</li>
            <li>\(\delta(\varepsilon, a) = \{\}\)</li>
            <li>\(\delta(a, a) = \{\varepsilon\}\)</li>
            <li>\(\delta(a, b) = \{\}\) where \(b \in A\) and \(b \neq a\)</li>
        </ol>
        and recursively, for any regular expressions \(r, r_1, r_2 \in \mathit{RExp}\):
        <ol start="5" type="A">
            <li>\(\delta(r_1 + r_2, a) = \delta(r_1, a) \cup \delta(r_2, a)\)</li>
            <li>\(\delta(r_1 \cdot r_2, a) = \{s \cdot r_2 \mid s \in \delta(r_1, a)\} \cup \{s \mid r_1 \in F \text{ and } s \in \delta(r_2, a)\}\)</li>
            <li>\(\delta(r^*, a) = \{s \cdot r^* \mid s \in \delta(r, a)\}\)</li>
        </ol>
        The elements of \(\delta(r, a)\) are called the <i>Antimirov \(a\)-derivatives of \(r\)</i>.
    </p>
</div>

<p>
    Antimirov derivatives are named after <a href="https://dblp.org/pid/94/4362.html" target="_blank">Valentin M. Antimirov</a>, who discovered them in the 1990s (although they implicitly appear in <a href="https://www.sciencedirect.com/science/article/pii/0022000084900230?via%3Dihub" target="_blank">a paper of Robin Milner's from the 1980s</a>). 
</p>

<p>
    To reiterate: states of \(\mathcal A_{Ant}\) are regular expressions.
    The transitions of \(\mathcal A_{Ant}\) are therefore transitions <i>between regular expressions</i>.
    And furthermore, like the Brzozowski automaton, transitions are given by derivatives. 
    Except, in this case, derivatives look a bit different: regular expressions can have multiple derivatives. 
    Before we get to the multiple-derivatives situation, let's look at a small example.
</p>

<div class="example">
    <b>(First Antimirov Derivatives)</b>
    Let's start with the regular expression \(a + b\).
    By E above, \(\delta(a + b, a) = \delta(a, a) \cup \delta(b, a)\).
    By C above, \(\delta(a, a) = \{\varepsilon\}\) and \(\delta(b, a) = \{\}\).
    This tells us that 
    \[
        \delta(a + b, a) = \delta(a, a) \cup \delta(b, a) = \{\varepsilon\} \cup \{\} = \{\varepsilon\}
    \]
    So that we would see in the Antimirov automaton that \(a + b \xrightarrow{a} \varepsilon\).
</div>

<div class="exercise">
    <b>(There's the b)</b>
    Find the Antimirov \(b\)-derivatives of \(a + b\). 
    That is, compute 
    \[
        \delta(a + b, b) = \text{?}
    \]
    in the Antimirov automaton.
</div>

<div class="example">
    Now let's take a look at \(a \cdot b\). 
    From F, 
    \[
        \delta(a\cdot b, a) = \{s \cdot b \mid s \in \delta(a, a)\} \cup \{s \mid a \in F \text{ and } s \in \delta(b, a)\}
    \]
    We know from i that \(a \notin F\), so \(\{s \mid a \in F \text{ and } s \in \delta(b, a)\} = \{\}\).
    Moreover, \(\delta(a, a) = \{\varepsilon\}\), so 
    \[\begin{aligned}
        \delta(a\cdot b, a) 
        &= \{s \cdot b \mid s \in \delta(a, a)\} \cup \{s \mid a \in F \text{ and } s \in \delta(b, a)\} && \text{(F)}\\
        &= \{s \cdot b \mid s \in \delta(a, a)\} \cup \{\} && \text{(i)}\\
        &= \{\varepsilon \cdot b\} \cup \{\} && \text{(C)}\\
        &= \{\varepsilon \cdot b\}
    \end{aligned}\]
    So, in the Antimirov automaton, you would see the transition \(a\cdot b \xrightarrow{a} \varepsilon \cdot b\).
</div>

<div class="exercise">
    <b>(Now where's the b gone?)</b>
    What is \(\delta(a \cdot b, b)\)?
    Draw the entire automaton of states of \(\mathcal A_{Ant}\) reachable from \(a\cdot b\).
</div>

<div class="example">
    <b>(Slightly More Complex Derivatives)</b>
    Let's do a slightly more complicated one. 
    If we plug-and-chug, derivatives can always be computed by unfolding the definitions, so let's do that for a more complicated example:
    given \(a,b,c \in A\), let's calculate the Antimirov \(a\)-derivatives of \(a\cdot b + a\cdot b\cdot c + \varepsilon\).
    \[\begin{aligned}
        \delta(a\cdot b + a\cdot b\cdot c + \varepsilon, a)
        &= \delta(a\cdot b, a) \cup \delta(a\cdot b\cdot c + \varepsilon, a)  &&\text{(E)} \\
        &= \delta(a\cdot b, a) \cup \delta(a\cdot b\cdot c, a) \cup \delta(\varepsilon, a)  &&\text{(E)} \\
        &= \{\varepsilon \cdot b\} \cup \delta(a\cdot b\cdot c, a) \cup \delta(\varepsilon, a)  &&\text{(F, v)} \\
        &= \{\varepsilon \cdot b\} \cup \{\varepsilon \cdot b \cdot c\} \cup \delta(\varepsilon, a)  &&\text{(F, v)} \\
        &= \{\varepsilon \cdot b\} \cup \{\varepsilon \cdot b \cdot c\} \cup \{\}  &&\text{(B)} \\
        &= \{\varepsilon \cdot b, \varepsilon \cdot b \cdot c\} 
    \end{aligned}\]
    Also notice that 
    \[\begin{aligned}
        a\cdot b + a \cdot b \cdot c + \varepsilon \in F 
        &\text{ if } a \cdot b \cdot c + \varepsilon \in F &&\text{(iv)} \\
        &\text{ if } \varepsilon \in F &&\text{(iv)} \\
        &\text{ and we know } \varepsilon \in F &&\text{(ii)} 
    \end{aligned}\]
    and therefore \(a\cdot b + a \cdot b \cdot c + \varepsilon \in F\).
    So, in the Antimirov automaton, you will see the following states and transitions:
    <div class="figure">
        <img src="../imgs/firstantimirov.svg" alt="Antimirov derivatives of ab+abc+epsilon are epsilon b, epsilon bc, and ab+abc+epsilon is accepting" />
        The first two derivatives of \(a\cdot b + a\cdot b \cdot c + \varepsilon\).
    </div>
</div>

<div class="exercise">
    <b>(Emenating Derivatives)</b>
    Draw state diagrams for the automaton \(\langle r_i\rangle_{\mathcal A_{Ant}}\) generated by each of the following regular expressions in the Antimirov Automaton over the alphabet \(A = \{a, b\}\).
    For each, determine what language is accepted by \(r\).
    <ol>
        <li>\(r_0 = abb + bab + \emptyset\)</li>
        <li>\(r_1 = a(b + ab) + \varepsilon\)</li>
        <li>\(r_2 = (a(b + ab) + \varepsilon a)b\)</li>
        <li>\(r_3 = a^*\) (just unravel the definition of \(\delta(a^*, a)\) here, but be careful! There's a hidden \(\varepsilon\) somewhere...)</li>
        <li>\(r_4 = (ab)^*\)</li>
        <li>\(r_5 = (ab^*)^*\)</li>
    </ol>
</div>

<h2>The Antimirov Fixed-point Theorem and \(\mathsf{Fin}\)</h2>

<p>
    The significance of the Antimirov automaton is twofold: first, that it is yet again an automaton that witnesses languages "accepting themselves" (actually, the language semantics of a regular expression).
</p>

<div class="theorem">
    <b>(Antimirov Fixed-point)</b>
    Let \(r \in \mathit{RExp}\) be a regular expression. 
    Then the language semantics of \(r\) is equal to the language accepted by the state \(r\) in the Antimirov automaton.
    \[
        \mathcal L(r) = \mathcal L(\mathcal A_{Ant}, r)
    \]
</div>

</p>
    OK, but we are not quite at a proof that \(\mathsf{Reg} \subseteq \mathsf{Fin}\), which is what we are aiming for.
    There are infinitely many states in \(\mathcal A_{Ant}\), because there are infinitely many regular expressions!
    However, the second point of significance for the Antimirov automaton is that the automaton generated by a regular expression in \(\mathcal A_{Ant}\), \(\langle r \rangle_{\mathcal A_{Ant}}\), is always finite. 
</p>

<div class="lemma">
    <b>(Linear Bound on Antimirov Derivatives)</b>
    For each regular expression \(r \in \mathit{RExp}\), define \(\#(r)\) to be the number of states reachable from \(r\) in the Antimirov Automaton.
    Then \(\#(r) < \infty\) for all \(r \in \mathit{RExp}\).
    In fact, where there are \(n\) operations in the formation of \(r\), \(\#(r) = O(n)\).
</div>

<p>
    The proof of the Antimirov fixed point theorem and the Linear Bound on Antimirov Derivatives lemma above proceed by <i>induction on regular expressions.</i>
    This is similar to vanilla induction and induction on words, but instead deals with regular expressions.
</p>

<div class="theorem">
    <b>(Induction on Regular Expressions)</b>
    Let \(S \subseteq \mathit{RExp}\) be a set of regular expressions. 
    Suppose that the following two statements hold:
    <ul>
        <li>(Base Case 1) \(\emptyset \in S\)</li>
        <li>(Base Case 2) \(\varepsilon \in S\)</li>
        <li>(Base Case 3) \(a \in S\) for all \(a \in A\)</li>
        <li>(Induction Step 1) If \(r_1,r_2 \in S\), then \(r_1 + r_2\in S\)</li>
        <li>(Induction Step 1) If \(r_1,r_2 \in S\), then \(r_1 \cdot r_2\in S\)</li>
        <li>(Induction Step 1) If \(r \in S\), then \(r^* \in S\)</li>
    </ul>
    Then \(S = \mathit{RExp}\).
</div>

<div class="proof">
    <b>(of the Antimirov Fixed Point Theorem)</b>
    Our goal is to show that for any \(r \in \mathit{RExp}\), \(\mathcal L(\mathcal A_{Ant}, r) = \mathcal L(r)\). 
    We proceed by induction on the regular expression \(r\).

    <p>
        The base cases are by calculation: 
        since \(\emptyset\) has no outgoing transitions and \(\emptyset\) is not an accepting state of \(\mathcal A_{Ant}\), then
        \[
            \mathcal L(\mathcal A_{Ant}, \emptyset) 
            = \{\} 
            = \mathcal L(\emptyset) 
        \]
        Since \(\varepsilon\) has no outgoing transitions and \(\varepsilon\) is an accepting state of \(\mathcal A_{Ant}\), then
        \[
            \mathcal L(\mathcal A_{Ant}, \varepsilon) 
            = \{\varepsilon\} 
            = \mathcal L(\varepsilon) 
        \]
        For each \(a \in A\), the automaton generated by the regular expression \(a \in \mathit{RExp}\) in \(\mathcal A_{Ant}\) is 
        \[
            \framebox{\(a\)} \xrightarrow{a} \framebox{\(\framebox{\(\varepsilon\)}\)}
        \]
        The language accepted by \(a\) in \(\mathcal A_{Ant}\) is therefore 
        \[
            \mathcal L(\mathcal A_{Ant}, a) 
            = \{a\} 
            = \mathcal L(a) 
        \]
        This concludes the base case.
    </p>

    <p>
        Let \(r,r_1,r_2 \in \mathit{RExp}\), and assume for an induction hypothesis that
        \[
            \mathcal L(\mathcal A_{Ant}, r) = \mathcal L(r)
            \quad
            \mathcal L(\mathcal A_{Ant}, r_1) = \mathcal L(r_1)
            \quad
            \mathcal L(\mathcal A_{Ant}, r_2) = \mathcal L(r_2)
        \]
        There are three induction steps. 
    </p>
    <ol>
        <li>
            In the first induction step, we consider the regular expression \(r_1 + r_2\).
            Since \(r_1 + r_2\) is an accepting state of \(\mathcal A_{Ant}\) if and only if either \(r_1\) is an accepting state or \(r_2\) is an accepting state, 
            \[\begin{aligned}
                &\varepsilon \in \mathcal L(\mathcal A_{Ant}, r_1 + r_2) \\
                &\text{ iff }
                \varepsilon \in \mathcal L(\mathcal A_{Ant}, r_1) \cup \mathcal L(\mathcal A_{Ant}, r_2)  \\
                &\text{ iff }
                \varepsilon \in \mathcal L(r_1) \cup \mathcal L(r_2) = \mathcal L(r_1 + r_2) &&\text{(IH)}
            \end{aligned}\]
            The last \(\text{iff}\) is the induction hypothesis.
            This shows that the empty word is in \(\mathcal L(\mathcal A_{Ant}, r_1 + r_2)\) if and only if it is in \(\mathcal L(r_1 + r_2)\). <br />

            It now suffices to show that a nonempty word is in \(\mathcal L(\mathcal A_{Ant}, r_1 + r_2)\) if and only if it is in \(\mathcal L(r_1 + r_2)\). 
            Every nonempty word is of the form \(aw\) for some \(a \in A\) and \(w \in A^*\). 
            So, we can reason as follows:
            \[\begin{aligned}
                &aw \in \mathcal L(\mathcal A_{Ant}, r_1 + r_2) \\
                &\text{ iff }
                r_1 + r_2 \xrightarrow{a} s \text{ and } w \in \mathcal L(\mathcal A_{Ant}, s)\\
                &\text{ iff either }
                r_1 \xrightarrow{a} s \text{ or } r_2 \xrightarrow{a} s \text{ and } w \in \mathcal L(\mathcal A_{Ant}, s)\\
                &\text{ iff }
                aw \in \mathcal L(\mathcal A_{Ant}, r_1) \text{ or } aw \in \mathcal L(\mathcal A_{Ant}, r_2)  \\
                &\text{ iff }
                \varepsilon \in \mathcal L(r_1) \cup \mathcal L(r_2) = \mathcal L(r_1 + r_2) &&\text{(IH)}
            \end{aligned}\]
            The last \(\text{iff}\) is the induction hypothesis.
        </li>
        <li>
            In the second induction step, we consider the regular expression \(r_1 \cdot r_2\). 
            We want to show that 
            \[
                \mathcal L(\mathcal A_{Ant}, r_1 \cdot r_2)
                = \mathcal L(r_1 \cdot r_2)
                = \mathcal L(r_1) \cdot \mathcal L(r_2)
            \]
            We are going to prove the two inclusions separately. 

            <p>
                In the forward inclusion, we want 
                \[
                    \mathcal L(\mathcal A_{Ant}, r_1 \cdot r_2) \subseteq \mathcal L(r_1) \cdot \mathcal L(r_2)
                    \qquad\text{(want!)}
                \]
                So, let \(w \in \mathcal L(\mathcal A_{Ant}, r_1 \cdot r_2)\) and write \(w = a_1 \cdots a_n\).
                Then there is a path 
                \[
                    r_1 \cdot r_2 \xrightarrow{a_1} t_1 \xrightarrow{a_2} t_2 \xrightarrow{a_3} \cdots \xrightarrow{a_n} t_n
                    \qquad \text{(*)}
                \]
                where \(t_n\) is an accepting state of \(\mathcal A_{Ant}\).
                There are two cases to consider: either 
                (1) all of the \(t_i\) are of the form \(t_i = s_i \cdot r_2\) for all \(i=1,\dots,n\) and \(s_n\) and \(r_2\) are accepting,
                 or 
                (2) there is a \(j \le n\) such that \(t_i = s_i \cdot r_2\) for \(i < j\), \(t_j = r_2\), and \(r_2 \xrightarrow{a_{j+1}} t_j \xrightarrow{a_{j+1}} \cdots \xrightarrow{a_n} t_n\).
            </p>
            <p>
                In case (1), the path in \(\text{(*)}\) looks like this:
                \[
                    r_1 \cdot r_2 \xrightarrow{a_1} s_1 \cdot r_2 \xrightarrow{a_2} s_2 \cdot r_2 \xrightarrow{a_3} \cdots \xrightarrow{a_n} s_n \cdot r_2
                \]
                In particular, this path tells us that the path below exists in \(\mathcal A_{Ant}\):
                \[
                    r_1 \xrightarrow{a_1} s_1 \xrightarrow{a_2} s_2 \xrightarrow{a_3} \cdots \xrightarrow{a_n} s_n
                \]
                Since \(s_n\) is accepting, \(w \in \mathcal L(\mathcal A_{Ant}, r_1)\). 
                The induction hypothesis tells us that \(w \in \mathcal L(\mathcal A_{Ant}, r_1) = \mathcal L(r_1)\), so \(w \in \mathcal L(r_1)\). 
                In case (1), \(r_2\) is accepting, so \(\varepsilon \in \mathcal L(A_{Ant}, r_2)\). 
                Again, the induction hypothesis now tells us that \(\varepsilon \in \mathcal L(r_2)\). 
                Therefore, \(w = w\varepsilon \in \mathcal L(r_1 \cdot r_2)\).
            </p>
            <p>
                In case (2), similar to case (1) we find \(a_1\cdots a_{j-1} \in \mathcal L(\mathcal A_{Ant}, r_1)\) and \(a_j \cdots \mathcal L(\mathcal A_{Ant}, r_2)\). 
                By the induction hypothesis, we therefore find \[
                    w = (a_1\cdots a_{j-1})(a_{j} \cdots a_n) \in \mathcal L(r_1) \cdot \mathcal L(r_2) = \mathcal L(r_1\cdot r_2)
                \]
            </p>

            We have just shown that \(\mathcal L(\mathcal A_{Ant}, r_1 \cdot r_2) \subseteq \mathcal L(r_1) \cdot \mathcal L(r_2)\).

            <p>
                For the opposite inclusion, let \(w = \mathcal L(r_1) \cdot \mathcal L(r_2)\).
                Then there are words \(u_1,u_2 \in A^*\) such that \(u_1 \in \mathcal L(r_1)\) and \(u_2 \in \mathcal L(r_2)\).
                By the induction hypothesis, \(u_1 \in \mathcal L(\mathcal A_{Ant}, r_1)\) and \(u_2 \in \mathcal L(\mathcal A_{Ant}, r_2)\).
                So, write
                \[
                    u_1 = a_1 \cdots a_n 
                    \quad 
                    u_2 = b_1 \cdots b_m
                \]
                Then by definition, there are paths
                \[\begin{aligned}
                    &r_1 \xrightarrow{a_1} s_1 \xrightarrow{a_2} s_2 \xrightarrow{a_3} \cdots \xrightarrow{a_n} s_n \\
                    &r_2 \xrightarrow{b_1} t_1 \xrightarrow{b_2} t_2 \xrightarrow{b_3} \cdots \xrightarrow{b_n} t_m 
                \end{aligned}\]
                in \(\mathcal A_{Ant}\) such that \(s_n,t_m\) are accepting. 
                By definition of \(\mathcal A_{Ant}\), we obtain the path 
                \[\begin{aligned}
                    &r_1 \xrightarrow{a_1} s_1\cdot r_2 \xrightarrow{a_2} \cdots \xrightarrow{a_n} s_n \cdot r_2
                    \xrightarrow{b_1} t_1 \xrightarrow{b_2} \cdots \xrightarrow{b_n} t_m 
                \end{aligned}\]
                in \(\mathcal A_{Ant}\). 
                This means that \[w = (a_1\cdots a_n)(b_1\cdots b_m) \in \mathcal L(\mathcal A_{Ant}, r_1 \cdot r_2)\]
            </p>
            We have just shown that \(\mathcal L(\mathcal A_{Ant}, r_1 \cdot r_2) \supseteq \mathcal L(r_1\cdot r_2)\), so this induction step is done.
        </li>
        <li>
            In the final induction step, we need to show that 
            \(
                \mathcal L(\mathcal A_{Ant}, r^*) = \mathcal L(r)^*
            \).
            Let \(w = a_1 \cdots a_n\).
            Every path of the form 
            \[
                r^* \xrightarrow{a_1} t_1 \xrightarrow{a_2} \cdots \xrightarrow{a_n} t_n
            \]
            is actually of the form 
            \[
                r^* \xrightarrow{a_1} s_1 \cdot r^* \xrightarrow{a_2} \cdots \xrightarrow{a_n} s_n \cdot r^*
                \qquad \text{(**)}
            \]
            in \(\mathcal A_{Ant}\), by definition, because every Antimirov derivative of \(r^*\) is of the form \(s \cdot r^*\) for some \(s\).
            Now, it's <b>not</b> necessarily true that we have a path 
            <span style="color: red;">\[
                r \xrightarrow{a_1} s_1 \xrightarrow{a_2} \cdots \xrightarrow{a_n} s_n
            \]</span>
            because one might have that the transition \(s_{i - 1} \cdot r^* \xrightarrow{a_i} s_i \cdot r^*\) exists because \(r \xrightarrow{a_i} s_i\) and \(s_{i-1}\) is accepting. 
            But this is the only pathology here, so we can find indices \(1 \le i_1, i_2, \dots, i_k \le n\) such that 
            \[
                s_{i_j-1} \text{ is accepting and }
                r \xrightarrow{a_{i_j}} s_{i_j}
                \qquad \text{(***)}
            \]
            Therefore, if the word \(w = a_1\cdots a_n\) is accepted by \(r^*\) in \(\mathcal A_{Ant}\) because of the path drawn above, then we can split \(w\) into 
            \[
                w = (a_1 \cdots a_{i_1-1})(a_{i_1} \cdots a_{i_2-1}) \cdots (a_{i_k} \cdots a_n)
            \]
            such that \(\text{(***)}\) holds for each \(j\).
            If we let \(u_j = (a_{i_{j-1}} \cdots a_{i_j-1})\) for each \(j\), then \(w = u_1 \dots u_k\) and \(u_j \in \mathcal L(\mathcal A_{Ant}, r)\) for each \(j\).
            By the induction hypothesis, \(u_j \in \mathcal L(r)\) for each \(j\), which means that
            \[
                w = u_1 \cdots u_k \in \mathcal L(r)^* = \mathcal L(r^*)
            \]
            This proves that \(\mathcal L(\mathcal A_{Ant}, r^*) \subseteq \mathcal L(r^*)\). 

            <p>
                For the opposite inclusion, let \(w \in \mathcal L(r^*)\). 
                Then by definition, there are \(u_1,\dots, u_k \in \mathcal L(r)\) such that \(w = u_1\cdots u_k\). 
                By the induction hypothesis, there is a path of the form \(\text{(***)}\) satisfying \(\text{(**)}\) above, so by definition of \(\mathcal A_{Ant}\), we find \(w \in \mathcal L(\mathcal A_{Ant}, r^*)\).
                This shows that \(\mathcal L(\mathcal A_{Ant}, r^*) \supseteq \mathcal L(r^*)\)
            </p>
        </li>
    </ol>
    This concludes the proof. 
</div>

<div class="proof">
    <b>(of the Linear Bound on Antimirov Derivatives Lemma)</b>
    We proceed by induction on regular expressions.
    Let
    \[
        S = \{r \in \mathit{RExp} \mid \#(r) \text{ is finite}\}
    \]
    In the base cases, we have 
    \[
        \#(\emptyset) = 1
        \quad 
        \#(\varepsilon) = 1
        \quad 
        \#(a) = 2
    \]
    for every \(a \in A\).
    That tells us that each of these is finite.
    So far, \(\#(r)\) has risen to the order of \(O(1)\).

    <p>
        Now, for the induction steps, suppose that \(r, r_1,r_2 \in S\).
        <ul>
            <li>
                (Induction Step 1)
                Every regular expression reachable from \(r_1 + r_2\) in \(\mathcal A_{Ant}\) is reachable from either \(r_1\) or \(r_2\).
                This means that
                \[\begin{aligned}
                    \#(r_1 + r_2) 
                    &\le |\{r_1 + r_2\} \cup \{s \mid r_1 \to \cdots \to s \} \cup \{s \mid r_2 \to \cdots \to s \}| \\
                    &\le 1 + \#(r_1) + \#(r_2)
                \end{aligned}\]
                Since \(r_1,r_2 \in S\), \(\#(r_1) + \#(r_2)\) is finite. 
                Therefore, \(\#(r_1 + r_2)\) is finite, so \(r_1 + r_2 \in S\).
                So far, \(\#(r)\) has risen to the order of \(O(\frac12 n) + O(\frac12 n) = O(n)\).
            </li>
            <li>
                (Induction Step 2)
                Every regular expression \(p \in \mathit{RExp}\) reachable from \(r_1 \cdot r_2\) in \(\mathcal A_{Ant}\) is of one of two forms: either \(p = s \cdot r_2\) where \(s\) is reachable from \(r_1\), or \(p = \varepsilon \cdot s\) where \(s\) is reachable from \(r_2\).
                Counting these up, we again see that 
                \[\begin{aligned}
                    \#(r_1 \cdot r_2) 
                    &\le |\{r_1 \cdot r_2\} \cup \{s \cdot r_2 \mid r_1 \to \cdots \to s \} \\
                    &\hspace{4em}\cup \{\varepsilon s \mid r_1 \to \cdots \to q \in F \text{ and } r_2 \to \cdots \to s \}| \\
                    &\le 1 + |\{s \mid r_1 \to \cdots \to s \} \\
                    &\hspace{4em}\cup \{s \mid r_2 \to \cdots \to s \}| \\
                    &\le 1 + \#(r_1) + \#(r_2)
                \end{aligned}\]
                Since \(r_1,r_2 \in S\), \(\#(r_1) + \#(r_2)\) is finite. 
                Therefore, \(\#(r_1 \cdot r_2)\) is finite, so \(r_1 \cdot r_2 \in S\).
                So far, \(\#(r)\) has risen to the order of \(O(\frac12 n) + O(\frac12 n) = O(n)\).
            </li>
            <li>
                (Induction Step 3)
                Every regular expression \(p \in \mathit{RExp}\) reachable from \(r^*\) is of the form \(p = s \cdot r^*\) for some \(s\) reachable from \(r\). 
                Therefore, 
                \[\begin{aligned}
                    \#(r^*) 
                    &\le |\{r^*\} \cup \{s \cdot r^* \mid r \to \cdots \to s \}| \\
                    &\le 1 + |\{s \mid r \to \cdots \to s \}| \\
                    &\le 1 + \#(r)
                \end{aligned}\]
                Since \(r \in S\), \(\#(r)\) is finite. 
                Therefore, \(\#(r^*)\) is finite, so \(r^* \in S\).
                So far, \(\#(r)\) has risen to the order of \(O(n)\).
            </li>
        </ul>
        By Induction on Regular Expressions, \(S = \mathit{RExp}\).
        Also, as we saw along the way, \(\#(r) = O(n)\).
    </p>
</div>

<p>
    Part of what is really nice about the Antimirov automaton is that the \(O(n)\) bound on the number of states shows us that these automata are relatively small.
</p>

<div class="exercise">
    <b>(Linearly Bounding for Yourself)</b>
    For the regular expressions \(r_1, r_2, r_5\) in the Emenating Derivates exercise, use the inequalities from the proof of the Linear Bound on Antimirov Derivatives Lemma to give upper bounds on the number of regular expressions reachable from \(r_i\).
    How does this number compare to the number of states you drew in their state diagrams?
</div>

<div class="theorem">
    <b>(Regularity is Finite)</b>
    Every regular language is finitely recognizable. 
    That is,
    \[
        \mathsf{Reg} \subseteq \mathsf{Fin}
    \]
</div>

<div class="proof">
    Let \(L\) be a regular language.
    Then there is a regular expression \(r \in \mathit{RExp}\) such that \(L = \mathcal L(r)\).
    By the Antimirov Fixed-point Theorem,
    \[
        L = \mathcal L(r) = \mathcal L(\mathcal A_{Ant}, r)
    \]
    But for any automaton \(\mathcal A\) with a state \(x\), \(\mathcal L(\mathcal A, x) = \mathcal L(\langle x \rangle_{\mathcal A}, x)\), because the language accepted by \(x\) does not depend on the states that are not reachable from \(x\).
    Setting \(\mathcal A = \mathcal A_{Ant}\) and \(x = r\), we obtain 
    \[
        L = \mathcal L(r) = \mathcal L(\mathcal A_{Ant}, r) = \mathcal L(\langle r \rangle_{\mathcal A_{Ant}}, r)
    \]
    By the Linear Bound on Antimirov Derivatives Lemma, \(\langle r \rangle_{\mathcal A_{Ant}}\) is finite.
    Therefore, \(r\) is a state in a finite automaton that accepts \(L\).
    By definition of \(\mathsf{Fin}\), we have \(L \in \mathsf{Fin}\), i.e., \(L\) is a finitely recognizable language.
</div>

<div class="problem">
    <b>(Some Nested Stars)</b>
    Consider the regular expression \(r = (a(b+c^*) + b)^*\) over the alphabet \(A = \{a,b,c\}\).
    <ol>
        <li>Name three different words \(w_0,w_1,w_1 \in A^*\) that are not in \(\mathcal L(r)\), i.e., \(w_0,w_1,w_2 \notin \mathcal L(r)\).</li>
        <li>Use the inequalities in the proof of the Linear Bound on Antimirov Derivatives Lemma to determine an upper bound on the number of states in the automaton \(\langle r\rangle_{\mathcal A_{Ant}}\) generated by \(r\) in \(\mathcal A_{Ant}\), i.e., \(\#(r)\).</li>
        <li>Now draw a state diagram of \(\langle r\rangle_{\mathcal A_{Ant}}\).</li>
        <li>How many formation rules were used to form the regular expression \(r\)? 
            How does this number of formation rules compare to the number of states in \(\langle r\rangle_{\mathcal A_{Ant}}\)?</li>
    </ol>
</div><div style="border: none; margin-bottom: -25px; padding: 0px; text-align: right;"><a href="../compiled/csci341_notes_1_08_regular_expressions.html"><span class="link"> &larr; regular expressions</span></a><a href="../compiled/csci341_notes_1_10_algebra_of_regex.html"><span class="link">algebra of regex &rarr;</span></a></div>


<!-- END OF BODY -->
    <div style="height: 50px;border-top: 1px solid rgb(131, 131, 131);margin-top: 50px; padding: 20px; text-align: right;">
        <a href=""><span class="link">Top</span></a>
    </div>
</div>
</div>
</body>


</html>