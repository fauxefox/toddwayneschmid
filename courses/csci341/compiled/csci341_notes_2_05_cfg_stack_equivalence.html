<!-- THIS IS A COMPILED FILE 
 Compiled on 2025-10-04 -->



































































































<!DOCTYPE html>

<head>
	
	<meta charset="UTF-8">
	<meta name="author" content="Todd Schmid">
	
	<!-- Renders latex formulas -->
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
	<!-- Renders tikz figures mid page -->
    <link rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css">
    <script src="https://tikzjax.com/v1/tikzjax.js"></script>
	
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
	<link rel="stylesheet" href="../../../styles.css" />
	<link rel="stylesheet" href="../../course_styles.css" />
	<link rel="icon" href="../../../squidab.png" />
	
	<!-- * Customize for each course * -->
	<title>CSCI 341 Theory of Computation</title>
	<meta name="description" content="Course pages for CSCI 341.">
	<meta name="keywords" content="bucknell,theory,computer,science,schmid,csci341">
	<!-- ***************************** -->
</head>

<body>

<div id="content">

<!-- Header Section -->
<div id="course_head" style="text-align: left;">
	<h1 style="margin-bottom: 0; text-align: left;">CSCI 341 Theory of Computation</h1>
	<i>Fall 2025, with <a href="../../../teaching.html">Schmid</a></i>
	<div id="links">
		<!-- * Customize for each course * -->
		<a href="csci341_index.html"><span class="link">Syllabus</span></a>
		<a href="csci341_contents.html"><span class="link">Notes</span></a>
		<a href="csci341_resources.html"><span class="link">Resources</span></a>
		<a href= "csci341_assignments.html"><span class="link">Assignments</span></a>
		<!-- ***************************** -->
	</div>
</div>



<div id="stuff">


<!-- BEGINNING OF BODY -->
<div style="border: none; margin-bottom: -25px; padding: 0px; text-align: right;"><a href="../compiled/csci341_notes_2_04_stack_automata.html"><span class="link"> &larr; stack automata</span></a></div><h1>Context-free = Stack Recognizable</h1>

<p>
    This lecture is going to be of a familiar nature, I think.
    We are going to show that two families of languages are equal. 
</p>

<p>
    Given an alphabet \(A\) of input letters, recall that a language \(L \subseteq A^*\) is <i>context-free</i> if there is a (context-free) grammar \(\mathcal G = (X, A, R)\) with a variable \(x \in X\) such that \(\mathcal L(\mathcal G, x) = L\). 
    And also, that the family of context-free languages is written \(\mathsf{CFL}\).
    Recall that \(L\) is<i>stack recognizable</i> if there is a stack automaton with finitely many states \(\mathcal S = (Q, A, \Sigma, \delta, F)\) with a state \(x\in Q\) such that \(\mathcal L(\mathcal S, x) = L\), and that the family of stack recognizable languages is written \(\mathsf{Stack}\).
    What we are going to prove is the following theorem:
</p>

<div class="theorem">
    <b>(CFL=Stack)</b>
    For any language \(L\), \(L\) is context-free if and only if it is stack recognizable. 
    That is,
    \[
        \mathsf{CFL} = \mathsf{Stack}
    \]
</div>

<p>
    The proof proceeds in the usual way one proves that two sets are equal: (1) we are going to show that \(\mathsf{CFL} \subseteq \mathsf{Stack}\) and then show that \(\mathsf{CFL} \supseteq \mathsf{Stack}\).
</p>

<h2>Every Context-free Language is a Stack Recognizable Language</h2>

<p>
    Let's start by showing (1), that \(\mathsf{CFL} \subseteq \mathsf{Stack}\).
    As might be expected, this is going to involve a construction that turns a grammar into a finite stack automaton.
</p>

<p>
    The basic idea behind the construction can be framed as matching the obligations of a <i>derivation</i>. 
    Every rewrite rule \(y \to \mu\) is going to correspond to a new obligation that the derivation has to fill.
    Note that this implies that both \(A\) and \(X\) are going to be contained in our set of stack symbols.
    This rewrite rule is modelled in the stack automaton with a path that pops \(y\) from the stack and pushes the characters of \(\mu\) to the stack in reverse order (because stacks are last-in-first-out) and pop each letter as it is being read.
    This captures that every derivation, say \(x_0 \Rightarrow \mu_1 \Rightarrow \cdots \Rightarrow \mu_n \Rightarrow w\), must end with a word \(w \in A^*\) (as opposed to a monomial expression \(\mu \in (X \cup A)^*\)).
    Every rewrite step, say \(\mu_i \Rightarrow \mu_{i+1}\), eliminates a variable from the previous expression, but it may introduce new ones. 
    If a rewrite step introduces a variable to the derivation, i.e., \(\mu_{i+1}\) has a variable in it, the deriver is obliged to later remove that variable with a rewrite rule. 
    Formally, the construction looks like this:
</p>

<div class="definition">
    <b>(Grammar-to-Automaton)</b>
    Let \(\mathcal G = (X, A, R)\) be a context-free grammar with a variable \(x_0\).
    Then the <i>stack automaton corresponding to \(x_0\)</i>, \(\mathcal S_{x_0} = (Q, A, \Sigma, \delta, F)\), is obtained by adding the collection of cycles, described after the following figure, starting from the state \(s_{\circlearrowleft}\), to the following state diagram:
    <div class="figure">
        <img src="../imgs/cfg_to_sta.svg" />
        The stack automaton \(\mathcal S_{x_0} = (Q, A, \Sigma, \delta, F)\).
        Here, 
        \[\begin{aligned}
            Q &= \{s_0, s_1, s_{\circlearrowleft}, s_\checkmark\} \cup (\text{more states added below}) \\
            \Sigma &= \{\bot\} \cup X \cup A \\
            \delta &= \{ \\
                &\hspace{2em} (s_0, (\varepsilon, \mathtt{push}~\bot), s_1), \\
                &\hspace{2em} (s_1, (\varepsilon, \mathtt{push}~x_0), s_{\circlearrowleft}), \\
                &\hspace{2em} (s_\circlearrowleft, (\varepsilon, \mathtt{pop}~\bot), s_{\checkmark}) \\
                &\hspace{1em} \} \cup (\text{more transitions added below}) \\
                F &= \{s_\checkmark\} 
        \end{aligned}\]
    </div> 
    The cycles that get added to the blue box in the figure are of the following form:
    <ol>
        <li>
            For each \(a \in A\), add a self-loop \(s_{\circlearrowleft} \xrightarrow{a \mid {\uparrow} a} s_{\circlearrowleft}\).
        </li>
        <li>
            For each rewrite rule \(y \to b_1b_2\cdots b_{n-1}b_n\), where \(y \in X\) and \(b_i \in X \cup A\) for each \(i\), add a cycle
            \[
                s_{\circlearrowleft} 
                \xrightarrow{{\uparrow} y} s_{n+1}
                \xrightarrow{{\downarrow} b_n} s_{n}
                \xrightarrow{{\downarrow} b_{n-1}} s_{n-1}
                \xrightarrow{{\downarrow} b_{n-2}} \cdots
                \xrightarrow{{\downarrow} b_{2}} s_2
                \xrightarrow{{\downarrow} b_{1}} s_{{\circlearrowleft}}
            \]
        </li>
    </ol>
    It is important to note that in this construction, other than sharing \(s_{\circlearrowleft}\), these cycles are pair-wise distinct.
</div>

<div class="lemma">
    <b>(Correctness of Grammar-to-Automaton)</b>
    Let \(\mathcal G = (X, A, R)\) be a context-free grammar with a variable \(x_0\). 
    Let \(\mathcal S_{x_0}\) be the stack automaton obtained from the Grammat-to-Automaton construction, in particular with the state \(s_0\).
    Then 
    \[
        \mathcal L(\mathcal S_{x_0}, s_0) = \mathcal L(\mathcal G, x_0)
    \]
</div>

<p>
    Note the extra symbol \(\bot\), called "bottom". 
    The role it plays in the structure of the automaton is going to be a running theme in later types of automata: it is really just there to delineate between two different parts of the program. 
    In this case, it delineates between states in which the stack can be empty and states where it cannot.
</p>

<div class="example">
    <b>(As vs Bs Again)</b>
    Recall the grammar \(\mathcal G = (\{x\}, \{a,b\}, \{(x, \varepsilon), (x, axb)\})\), also depicted below:
    \[
        x \to \varepsilon \mid axb
    \]
    Using the Grammar-to-Automaton construction, we obtain the following stack automaton \(\mathcal S_x = (Q, A, \{\bot\}\cup X \cup A, \delta, F)\):
    <img src="../imgs/cfg_to_sta_example.svg" />
    To see how the string \(aabb \in \mathcal L(\mathcal G, x)\) is accepted by this stack automaton, consider the path
    \[\begin{aligned}
        s_0 
        &\xrightarrow{{\downarrow}\bot} s_1  
        \xrightarrow{{\downarrow}x} s_{\circlearrowleft} 
        \xrightarrow{{\uparrow}x} s_4 
        \xrightarrow{{\downarrow}b} s_3 
        \xrightarrow{{\downarrow}x} s_2 \\
        &\hspace{2em}\xrightarrow{{\downarrow}a} s_{\circlearrowleft} 
        \xrightarrow{a \mid {\uparrow}a} s_{\circlearrowleft} 
        \xrightarrow{{\uparrow}x} s_4 
        \xrightarrow{{\downarrow}b} s_3 
        \xrightarrow{{\downarrow}x} s_2 \\
        &\hspace{4em}\xrightarrow{{\downarrow}a} s_{\circlearrowleft} 
        \xrightarrow{a \mid {\uparrow}a} s_{\circlearrowleft} 
        \xrightarrow{{\uparrow}x} s_{\circlearrowleft} 
        \xrightarrow{b \mid {\uparrow}b} s_{\circlearrowleft} 
        \xrightarrow{b \mid {\uparrow}b} s_{\circlearrowleft} 
        \xrightarrow{{\uparrow}\bot} s_\checkmark
    \end{aligned}\]
    This is a path that reads \(aabb\), so it is a candidate for a successful run of \(aabb\) starting from \(s_0\). 
    To see that it is a successful run, we need to check that its program starts and ends with an empty stack and doesn't crash, i.e., that it reduces to \(\mathtt{skip}\).
    Here's the calculation, with brackets around push-pop pairs that are eliminated on the next line:
    \[\begin{aligned}
        &{\downarrow}\bot
        {\color{blue}({\downarrow}x
        {\uparrow}x)}
        {\downarrow}b
        {\downarrow}x
        {\downarrow}a
        {\uparrow}a
        {\uparrow}x
        {\downarrow}b
        {\downarrow}x
        {\downarrow}a
        {\uparrow}a
        {\uparrow}x
        {\uparrow}b
        {\uparrow}b
        {\uparrow}\bot 
        \\
        &= {\downarrow}\bot
        {\downarrow}b
        {\downarrow}x
        {\color{blue}({\downarrow}a
        {\uparrow}a)}
        {\uparrow}x
        {\downarrow}b
        {\downarrow}x
        {\downarrow}a
        {\uparrow}a
        {\uparrow}x
        {\uparrow}b
        {\uparrow}b
        {\uparrow}\bot \\
        &= {\downarrow}\bot
        {\downarrow}b
        {\downarrow}x
        {\uparrow}x
        {\downarrow}b
        {\downarrow}x
        {\color{blue}({\downarrow}a
        {\uparrow}a)}
        {\uparrow}x
        {\uparrow}b
        {\uparrow}b
        {\uparrow}\bot \\
        &= {\downarrow}\bot
        {\downarrow}b
        {\color{blue}({\downarrow}x
        {\uparrow}x)}
        {\downarrow}b
        {\downarrow}x
        {\uparrow}x
        {\uparrow}b
        {\uparrow}b
        {\uparrow}\bot \\
        &= {\downarrow}\bot
        {\downarrow}b
        {\downarrow}b
        {\color{blue}({\downarrow}x
        {\uparrow}x)}
        {\uparrow}b
        {\uparrow}b
        {\uparrow}\bot \\
        &= {\downarrow}\bot
        {\downarrow}b
        {\color{blue}({\downarrow}b
        {\uparrow}b)}
        {\uparrow}b
        {\uparrow}\bot \\
        &= {\downarrow}\bot
        {\color{blue}({\downarrow}b
        {\uparrow}b)}
        {\uparrow}\bot \\
        &= {\color{blue}({\downarrow}\bot
        {\uparrow}\bot)} \\
        &= \mathtt{skip}
    \end{aligned}\]
    A lot of work for \(aabb\), but at least we know it's correct!
</div>

<div class="exercise">
    <b>(Less-Involved)</b>
    Consider the stack automaton in the As vs Bs Again example again. 
    Show that \(s_0\) accepts the word \(ab\) by writing down the accepting run that reads \(ab\) starting from \(s_0\) and reducing the stack program in the run to \(\mathtt{skip}\).

</div>

<div class="exercise">
    <b>(Full-Stack)</b>
    For each of the words \(w_i\) and grammars \(\mathcal G_i\) below, calculate the stack automaton corresponding to the variable \(x\) and show that the stack automaton's \(s_0\) accepts \(w_i\).
    <ol>
        <li>The word is \(w_1 = abc\), and the grammar
            \[\mathcal G_1 = 
                \begin{aligned}
                    x &\to axy \mid \varepsilon \\
                    y &\to byc \mid \varepsilon 
                \end{aligned}
            \]
        </li>
        <li>The word is \(w_2 = 0110\), and the grammar
            \[\mathcal G_2 = 
                \begin{aligned}
                    x &\to 0x1 \mid 1 x 0 \mid \varepsilon 
                \end{aligned}
            \]
        </li>
    </ol>
</div>


<!-- 
<div class="individual-exercise">
    <b>(Tight-90)</b>
</div> -->

<h2>Every Stack Recognizable Language is a Context-free Language</h2>

<p>
    Now let's show that \(\mathsf{Stack} \subseteq \mathsf{CFL}\).
    This is going to involve a construction that turns a stack automaton into a grammar.
    In fact, as we will see, a stack automaton is kind of already itself a compact representation of a grammar.
    But be warned, the word "compact" here is an understatement: the grammar corresponding to a stack automaton can be extremely large compared to the original automaton (although still finite).
</p>

<h2>Consequences of CFL=Stack</h2>

<p>
    Knowing that context-free languages are the same as stack recognizable languages opens up our study of context-free languages by allowing us to use automata-theoretic tools to study them.
    In particular, we can make use of constructions like the <i>product construction</i> from earlier, although it's not as simply applied as before.
</p>

<div class="theorem">
    <b>(Intersecting with a Regular Language)</b>
    The intersection of a <b>regular</b> language and a context-free language is context-free.
</div>

<div class="proof">
    (Sketch!)
    
</div>

<div class="problem">
    <b>(Closure Properties)</b>
    Show that \(\mathsf{CFL}\) is closed under unions in two ways:
    <ol>
        <li>Directly show that the union of two context-free languages \(L_1,L_2 \in \mathsf{CFL}\) is context free by constructing a grammar \(\mathcal G\) with a variable that derives their union, \(L_1 \cup L_2\).</li>
        <li>Use epsilon transitions to show that the union of two languages in \(\mathsf{Stack}\) is also in \(\mathsf{Stack}\). Then refer to the CFL=Stack theorem.</li>
    </ol>
</div><div style="border: none; margin-bottom: -25px; padding: 0px; text-align: right;"><a href="../compiled/csci341_notes_2_04_stack_automata.html"><span class="link"> &larr; stack automata</span></a></div>


<!-- END OF BODY -->
    <div style="height: 50px;border-top: 1px solid rgb(131, 131, 131);margin-top: 50px; padding: 20px; text-align: right;">
        <a href=""><span class="link">Top</span></a>
    </div>
</div>
</div>
</body>


</html>