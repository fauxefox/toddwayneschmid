<!-- THIS IS A COMPILED FILE 
 Compiled on 2025-10-03 -->



































































































<!DOCTYPE html>

<head>
	
	<meta charset="UTF-8">
	<meta name="author" content="Todd Schmid">
	
	<!-- Renders latex formulas -->
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
	<!-- Renders tikz figures mid page -->
    <link rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css">
    <script src="https://tikzjax.com/v1/tikzjax.js"></script>
	
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
	<link rel="stylesheet" href="../../../styles.css" />
	<link rel="stylesheet" href="../../course_styles.css" />
	<link rel="icon" href="../../../squidab.png" />
	
	<!-- * Customize for each course * -->
	<title>CSCI 341 Theory of Computation</title>
	<meta name="description" content="Course pages for CSCI 341.">
	<meta name="keywords" content="bucknell,theory,computer,science,schmid,csci341">
	<!-- ***************************** -->
</head>

<body>

<div id="content">

<!-- Header Section -->
<div id="course_head" style="text-align: left;">
	<h1 style="margin-bottom: 0; text-align: left;">CSCI 341 Theory of Computation</h1>
	<i>Fall 2025, with <a href="../../../teaching.html">Schmid</a></i>
	<div id="links">
		<!-- * Customize for each course * -->
		<a href="csci341_index.html"><span class="link">Syllabus</span></a>
		<a href="csci341_contents.html"><span class="link">Notes</span></a>
		<a href="csci341_resources.html"><span class="link">Resources</span></a>
		<a href= "csci341_assignments.html"><span class="link">Assignments</span></a>
		<!-- ***************************** -->
	</div>
</div>



<div id="stuff">


<!-- BEGINNING OF BODY -->
<div style="border: none; margin-bottom: -25px; padding: 0px; text-align: right;"><a href="../compiled/csci341_notes_2_04_stack_automata.html"><span class="link"> &larr; stack automata</span></a></div><h1>Context-free = Stack Recognizable</h1>

<p>
    This lecture is going to be of a familiar nature, I think.
    We are going to show that two families of languages are equal. 
</p>

<p>
    Given an alphabet \(A\) of input letters, recall that a language \(L \subseteq A^*\) is <i>context-free</i> if there is a (context-free) grammar \(\mathcal G = (X, A, R)\) with a variable \(x \in X\) such that \(\mathcal L(\mathcal G, x) = L\). 
    And also, that the family of context-free languages is written \(\mathsf{CFL}\).
    Recall that \(L\) is<i>stack recognizable</i> if there is a stack automaton with finitely many states \(\mathcal S = (Q, A, \Sigma, \delta, F)\) with a state \(x\in Q\) such that \(\mathcal L(\mathcal S, x) = L\), and that the family of stack recognizable languages is written \(\mathsf{Stack}\).
    What we are going to prove is that 
    \[
        \mathsf{CFL} = \mathsf{Stack}
    \]
    We will do this in the usual way one proves that two sets are equal: (1) we are going to show that \(\mathsf{CFL} \subseteq \mathsf{Stack}\) and then show that \(\mathsf{CFL} \supseteq \mathsf{Stack}\).
</p>

<h2>Every Context-free Language is a Stack Recognizable Language</h2>

<p>
    Let's start by showing (1), that \(\mathsf{CFL} \subseteq \mathsf{Stack}\).
    As might be expected, this is going to involve a construction that turns a grammar into a finite stack automaton.
</p>

<p>
    The basic idea behind the construction can be framed as matching the obligations of a <i>derivation</i>. 
    Every rewrite rule \(y \to \mu\) is going to correspond to a new obligation that the derivation has to fill.
    Note that this implies that both \(A\) and \(X\) are going to be contained in our set of stack symbols.
    This rewrite rule is modelled in the stack automaton with a path that pops \(y\) from the stack and pushes the characters of \(\mu\) to the stack in reverse order (because stacks are last-in-first-out) and pop each letter as it is being read.
    This captures that every derivation, say \(x_0 \Rightarrow \mu_1 \Rightarrow \cdots \Rightarrow \mu_n \Rightarrow w\), must end with a word \(w \in A^*\) (as opposed to a monomial expression \(\mu \in (X \cup A)^*\)).
    Every rewrite step, say \(\mu_i \Rightarrow \mu_{i+1}\), eliminates a variable from the previous expression, but it may introduce new ones. 
    If a rewrite step introduces a variable to the derivation, i.e., \(\mu_{i+1}\) has a variable in it, the deriver is obliged to later remove that variable with a rewrite rule. 
    Formally, the construction looks like this:
</p>

<div class="definition">
    <b>(Grammar-to-Automaton)</b>
    Let \(\mathcal G = (X, A, R)\) be a context-free grammar with a variable \(x_0\).
    Then the <i>stack automaton corresponding to \(x_0\)</i>, \(\mathcal S_{x_0} = (Q, A, \Sigma, \delta, F)\), is obtained by adding the collection of cycles, described after the following figure, starting from the state \(s_{\circlearrowleft}\), to the following state diagram:
    <div class="figure">
        <img src="../imgs/cfg_to_sta.svg" />
        The stack automaton \(\mathcal S_{x_0} = (Q, A, \Sigma, \delta, F)\).
        Here, 
        \[\begin{aligned}
            Q &= \{s_0, s_1, s_{\circlearrowleft}, s_\checkmark\} \cup (\text{more states added below}) \\
            \Sigma &= \{\bot\} \cup X \cup A \\
            \delta &= \{ \\
                &\hspace{2em} (s_0, (\varepsilon, \mathtt{push}~\bot), s_1), \\
                &\hspace{2em} (s_1, (\varepsilon, \mathtt{push}~x_0), s_{\circlearrowleft}), \\
                &\hspace{2em} (s_\circlearrowleft, (\varepsilon, \mathtt{pop}~\bot), s_{\checkmark}) \\
                &\} \cup (\text{more transitions added below}) \\
                F &= \{s_\checkmark\} 
        \end{aligned}\]
    </div> 
    The cycles that get added to the blue box in the figure are of the following form:
    <ol>
        <li>
            For each \(a \in A\), add a self-loop \(s_{\circlearrowleft} \xrightarrow{a \mid {\uparrow} a} s_{\circlearrowleft}\).
        </li>
        <li>
            For each rewrite rule \(y \to b_1b_2\cdots b_{n-1}b_n\), where \(y \in X\) and \(b_i \in X \cup A\) for each \(i\), add a cycle
            \[
                s_{\circlearrowleft} 
                \xrightarrow{{\uparrow} y} s_{n+1}
                \xrightarrow{{\downarrow} b_n} s_{n}
                \xrightarrow{{\downarrow} b_{n-1}} s_{n-1}
                \xrightarrow{{\downarrow} b_{n-2}} \cdots
                \xrightarrow{{\downarrow} b_{2}} s_2
                \xrightarrow{{\downarrow} b_{1}} s_{{\circlearrowleft}}
            \]
        </li>
    </ol>
    It is important to note that in this construction, other than sharing \(s_{\circlearrowleft}\), these cycles are pair-wise distinct.
</div>

<div class="example">
    <b>(As vs Bs Again)</b>
    Recall the grammar \(\mathcal G = (\{x\}, \{a,b\}, \{(x, \varepsilon), (x, axb)\})\), also depicted below:
    \[
        x \to \varepsilon \mid axb
    \]
    Using the Grammar-to-Automaton construction, we obtain the following stack automaton \(\mathcal S_x = (Q, A, \{\bot\}\cup X \cup A, \delta, F)\):
    <img src="../imgs/cfg_to_sta_example.svg" />
    To see how the string \(aabb \in \mathcal L(\mathcal G, x)\) is accepted by this stack automaton, consider the path
    \[\begin{aligned}
        s_0 
        &\xrightarrow{{\downarrow}\bot} s_1  
        \xrightarrow{{\downarrow}x} s_{\circlearrowleft} 
        \xrightarrow{{\uparrow}x} s_4 
        \xrightarrow{{\downarrow}b} s_3 
        \xrightarrow{{\downarrow}x} s_2 \\
        &\hspace{2em}\xrightarrow{{\downarrow}a} s_{\circlearrowleft} 
        \xrightarrow{a \mid {\uparrow}a} s_{\circlearrowleft} 
        \xrightarrow{{\uparrow}x} s_4 
        \xrightarrow{{\downarrow}b} s_3 
        \xrightarrow{{\downarrow}x} s_2 \\
        &\hspace{4em}\xrightarrow{{\downarrow}a} s_{\circlearrowleft} 
        \xrightarrow{a \mid {\uparrow}a} s_{\circlearrowleft} 
        \xrightarrow{{\uparrow}x} s_{\circlearrowleft} 
        \xrightarrow{b \mid {\uparrow}b} s_{\circlearrowleft} 
        \xrightarrow{b \mid {\uparrow}b} s_{\circlearrowleft} 
        \xrightarrow{{\uparrow}\bot} s_\checkmark
    \end{aligned}\]
    This is a path that reads \(aabb\), so it is a candidate for a successful run of \(aabb\) starting from \(s_0\). 
    To see that it is a successful run, we need to check that its program starts and ends with an empty stack and doesn't crash, i.e., that it reduces to \(\mathtt{skip}\).
    Here's the calculation, with brackets around push-pop pairs that are eliminated on the next line:
    \[\begin{aligned}
        &{\downarrow}\bot
        {\color{blue}({\downarrow}x
        {\uparrow}x)}
        {\downarrow}b
        {\downarrow}x
        {\downarrow}a
        {\uparrow}a
        {\uparrow}x
        {\downarrow}b
        {\downarrow}x
        {\downarrow}a
        {\uparrow}a
        {\uparrow}x
        {\uparrow}b
        {\uparrow}b
        {\uparrow}\bot \\
        &= {\downarrow}\bot
        {\downarrow}b
        {\downarrow}x
        ({\downarrow}a
        {\uparrow}a)
        {\uparrow}x
        {\downarrow}b
        {\downarrow}x
        {\downarrow}a
        {\uparrow}a
        {\uparrow}x
        {\uparrow}b
        {\uparrow}b
        {\uparrow}\bot \\
        &= {\downarrow}\bot
        {\downarrow}b
        {\downarrow}x
        {\uparrow}x
        {\downarrow}b
        {\downarrow}x
        ({\downarrow}a
        {\uparrow}a)
        {\uparrow}x
        {\uparrow}b
        {\uparrow}b
        {\uparrow}\bot \\
        &= {\downarrow}\bot
        {\downarrow}b
        ({\downarrow}x
        {\uparrow}x)
        {\downarrow}b
        {\downarrow}x
        {\uparrow}x
        {\uparrow}b
        {\uparrow}b
        {\uparrow}\bot \\
        &= {\downarrow}\bot
        {\downarrow}b
        {\downarrow}b
        ({\downarrow}x
        {\uparrow}x)
        {\uparrow}b
        {\uparrow}b
        {\uparrow}\bot \\
        &= {\downarrow}\bot
        {\downarrow}b
        ({\downarrow}b
        {\uparrow}b)
        {\uparrow}b
        {\uparrow}\bot \\
        &= {\downarrow}\bot
        ({\downarrow}b
        {\uparrow}b)
        {\uparrow}\bot \\
        &= ({\downarrow}\bot
        {\uparrow}\bot) \\
        &= \varepsilon
    \end{aligned}\]
</div>

<div class="individual-exercise">
    <b>(Tight-90)</b>
</div>

<h2>Every Stack Recognizable Language is a Context-free Language</h2>

<p>
    Now let's show that \(\mathsf{Stack} \subseteq \mathsf{CFL}\).
    This is going to involve a construction that turns a stack automaton into a grammar.
    In fact, as we will see, a stack automaton is kind of already itself a compact representation of a grammar.
    But be warned, the word "compact" here is an understatement: the grammar corresponding to a stack automaton can be extremely large compared to the original automaton (although still finite).
</p><div style="border: none; margin-bottom: -25px; padding: 0px; text-align: right;"><a href="../compiled/csci341_notes_2_04_stack_automata.html"><span class="link"> &larr; stack automata</span></a></div>


<!-- END OF BODY -->
    <div style="height: 50px;border-top: 1px solid rgb(131, 131, 131);margin-top: 50px; padding: 20px; text-align: right;">
        <a href=""><span class="link">Top</span></a>
    </div>
</div>
</div>
</body>


</html>